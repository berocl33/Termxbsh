package com.termx;
import android.app.Activity;
import android.content.Intent;


public class ActionActivity extends Activity {
 protected static final String TAG = "ActionActivity";
 protected static final int ITEM_POP = Menu.FIRST;
 protected static final int menuSize = 0;

 @Override
 public void onCreate(Bundle savedInstance){
  super.onCreate(savedInstance);
  ActionBar actions =getActionBar();
  EditText view = new EditText(this);
  setContentView(view);
   
  final PopupMenu popup = new PopupMenu(this,textview);
  popup.inflate(R.menu.popup);
  popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
   public boolean onMenuItemClick(MenuItem item){
    switch (item.getItemId()) {
     case (ITEM_POP):
     default:
    }
   }


  });
  view.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE);
  view.setOnSystemUiVisibilityChangeListener(new OnSystemUiVisibilityChangeListener(){
   public void onSystemUiVisibilityChange(int visibility){
    if (visibility==View.SYSTEM_UI_FLAG_VISIBLE)
     getActionBar().show();
    else 
     getActionBar().hide();
   }
  });
 }
 public boolean onOptionsItemSelected(MenuItem item){
  super.onOptionsItemSelected(item);
  int cmds=item.getItemId();
  if (cmds < )
   
    

  }
 }
 @Override
 public boolean onCreateOptionsMenu(Menu menu){
  super.onCreateOptionsMenu(menu);
  int values=0;
  int menuItemOrder=Menu.NONE;
  MenuItem menuitem = menu.add(values,Menu.FIRST+menuSize,menuItemOrder,name); 
  menuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT);
 }

}
package com.termx;

import android.app.ActionBar;
import android.app.ActionBar.OnNavigationListener;
import android.app.Activity;
import android.os.Bundle;
import android.widget.ArrayAdapter;

public class ActionBarDropDownActivity extends Activity {

  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
    
    ActionBar actionBar = getActionBar();
    
    /**
     * Listing 10-10: Creating an Action Bar drop-down list
     */
    // Select the drop-down navigation mode.
    actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);
    
    // Create a new Spinner Adapter that contains the values to
    // be displayed in the drop down.
    ArrayAdapter dropDownAdapter = 
      ArrayAdapter.createFromResource(this,
                                      R.array.my_dropdown_values,
                                      android.R.layout.simple_list_item_1);
    
    // Assign the callbacks to handle drop-down selections.
    actionBar.setListNavigationCallbacks(dropDownAdapter, 
      new OnNavigationListener() {
        public boolean onNavigationItemSelected(int itemPosition, 
                                                long itemId) {
          // TODO Modify your UI based on the position 
          // of the drop down item selected.
          return true;
        }
     }); 
  }
}
package com.termx;

import android.app.Fragment;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

public class MyFragment extends Fragment {
  
  public void setFragmentText(CharSequence text) {
    fragmentTextString = text;
    if (fragmentText != null)
      fragmentText.setText(text);
  }
  
  private CharSequence fragmentTextString = "";
  private TextView fragmentText;
  
  

  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setHasOptionsMenu(true);
  }

  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container,
    Bundle savedInstanceState) {
     
    View view = inflater.inflate(R.layout.fragment, container, false);
    
    fragmentText = (TextView)view.findViewById(R.id.fragmentText);
    fragmentText.setText(fragmentTextString);
    
    return view;
  }
}package com.paad.preferences;

import android.app.Fragment;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.TextView;

public class MyFragment extends Fragment {
  
  private static String USER_SELECTION = "USER_SELECTION";
  private int userSelection = 0;
  private TextView tv;
  
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setRetainInstance(true);
    if (savedInstanceState != null)
      userSelection = savedInstanceState.getInt(USER_SELECTION);
  }

  @Override
  public View onCreateView(LayoutInflater inflater, 
                           ViewGroup container,
                           Bundle savedInstanceState) {
    View v = inflater.inflate(R.layout.mainfragment, container, false);
    
    tv = (TextView)v.findViewById(R.id.text);
    setSelection(userSelection);
    
    Button b1 = (Button)v.findViewById(R.id.button1);
    Button b2 = (Button)v.findViewById(R.id.button2);
    Button b3 = (Button)v.findViewById(R.id.button3);
    
    b1.setOnClickListener(new OnClickListener() {
      public void onClick(View view) {
        setSelection(1);
      }
    });
   
    b2.setOnClickListener(new OnClickListener() {
      public void onClick(View view) {
        setSelection(2);
      }
    });
    
    b3.setOnClickListener(new OnClickListener() {
      public void onClick(View view) {
        setSelection(3);
      }
    });
    
    return v;
  }
  
  private void setSelection(int selection) {
    userSelection = selection;
    tv.setText("Selected: " + selection);
  }

  @Override
  public void onSaveInstanceState(Bundle outState) {
    outState.putInt(USER_SELECTION, userSelection);
    super.onSaveInstanceState(outState);
  }
}
package com.termx; 

import android.app.ActionBar;
import android.app.ActionBar.Tab;
import android.app.Activity;
import android.app.Fragment;
import android.app.FragmentTransaction;
import android.os.Bundle;

public class ActionTabActivity extends Activity {
  
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    ActionBar actionBar = getActionBar();
    
    actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
    actionBar.setDisplayShowTitleEnabled(false);
    
    for (int a=0;a<menuSize;a++){
     Tab tab = actionBar.newTab();

     tab.setText(consName)
          .setIcon(R.drawable.ic_launcher)
          .setContentDescription(consAction)
          .setTabListener(
             new TabListener<MyFragment>
               (this, R.id.fragmentContainer, MenuFragment.class));

     actionBar.addTab(tab);

  }

  public static class TabListener<T extends Fragment> 
    implements ActionBar.TabListener {
    
    private MyFragment fragment;
    private Activity activity;
    private Class<T> fragmentClass;
    private int fragmentContainer;

    public TabListener(Activity activity, int fragmentContainer, 
                       Class<T> fragmentClass) {

      this.activity = activity;
      this.fragmentContainer = fragmentContainer;
      this.fragmentClass = fragmentClass;
    }

    // Called when a new tab has been selected
    public void onTabSelected(Tab tab, FragmentTransaction ft) {
      if (fragment == null) {
        String fragmentName = fragmentClass.getName();
        fragment =
          (MenuFragment)Fragment.instantiate(activity, fragmentName);
        ft.add(fragmentContainer, fragment, null);
        fragment.setFragmentText(tab.getText());
      } else {
        ft.attach(fragment);
      }
    }

    // Called on the currently selected tab when a different tag is
    // selected. 
    public void onTabUnselected(Tab tab, FragmentTransaction ft) {
      if (fragment != null) {
        ft.detach(fragment);
      }
    } 

    // Called when the selected tab is selected.
    public void onTabReselected(Tab tab, FragmentTransaction ft) {
      // TODO React to a selected tab being selected again.
    }
  }
}
package com.termx;

import android.text.AndroidCharacter;

/**
 * Definitions related to android.text.AndroidCharacter
 */
public class AndroidCharacterCompat {
    public static final int EAST_ASIAN_WIDTH_NEUTRAL = 0;
    public static final int EAST_ASIAN_WIDTH_AMBIGUOUS = 1;
    public static final int EAST_ASIAN_WIDTH_HALF_WIDTH = 2;
    public static final int EAST_ASIAN_WIDTH_FULL_WIDTH = 3;
    public static final int EAST_ASIAN_WIDTH_NARROW = 4;
    public static final int EAST_ASIAN_WIDTH_WIDE = 5;

    private static class Api8OrLater {
        public static int getEastAsianWidth(char c) {
            return AndroidCharacter.getEastAsianWidth(c);
        }
    }

    public static int getEastAsianWidth(char c) {
        if (AndroidCompat.SDK >= 8) {
            return Api8OrLater.getEastAsianWidth(c);
        } else {
            return EAST_ASIAN_WIDTH_NARROW;
        }
    }
}
package com.termx;

/**
 * The classes in this package take advantage of the fact that the VM does
 * not attempt to load a class until it's accessed, and the verifier
 * does not run until a class is loaded.  By keeping the methods which
 * are unavailable on older platforms in subclasses which are only ever
 * accessed on platforms where they are available, we can preserve
 * compatibility with older platforms without resorting to reflection.
 *
 * See http://developer.android.com/resources/articles/backward-compatibility.html
 * and http://android-developers.blogspot.com/2010/07/how-to-have-your-cupcake-and-eat-it-too.html
 * for further discussion of this technique.
 */

public class AndroidCompat {
    public final static int SDK = getSDK();

    private final static int getSDK() {
        int result;
        try {
            result = AndroidLevel4PlusCompat.getSDKInt();
        } catch (VerifyError e) {
            // We must be at an SDK level less than 4.
            try {
                result = Integer.valueOf(android.os.Build.VERSION.SDK);
            } catch (NumberFormatException e2) {
                // Couldn't parse string, assume the worst.
                result = 1;
            }
        }
        return result;
    }
}

class AndroidLevel4PlusCompat {
    static int getSDKInt() {
        return android.os.Build.VERSION.SDK_INT;
    }
}
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.termx;

import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PixelXorXfermode;
import android.graphics.RectF;
import com.termx.AndroidCharacterCompat;

abstract class BaseTextRenderer implements TextRenderer {
    protected boolean mReverseVideo;

    protected int[] mPalette;

    protected static final int[] sXterm256Paint = {
            // 16 original colors
            // First 8 are dim
            0xff000000,  // black
            0xffcd0000,  // dim red
            0xff00cd00,  // dim green
            0xffcdcd00,  // dim yellow
            0xff0000ee,  // dim blue
            0xffcd00cd,  // dim magenta
            0xff00cdcd,  // dim cyan
            0xffe5e5e5,  // dim white
            // second 8 are bright
            0xff7f7f7f,  // medium grey
            0xffff0000,  // bright red
            0xff00ff00,  // bright green
            0xffffff00,  // bright yellow
            0xff5c5cff,  // light blue
            0xffff00ff,  // bright magenta
            0xff00ffff,  // bright cyan
            0xffffffff,  // bright white

            // 216 color cube, six shades of each color
            0xff000000,
            0xff00005f,
            0xff000087,
            0xff0000af,
            0xff0000d7,
            0xff0000ff,
            0xff005f00,
            0xff005f5f,
            0xff005f87,
            0xff005faf,
            0xff005fd7,
            0xff005fff,
            0xff008700,
            0xff00875f,
            0xff008787,
            0xff0087af,
            0xff0087d7,
            0xff0087ff,
            0xff00af00,
            0xff00af5f,
            0xff00af87,
            0xff00afaf,
            0xff00afd7,
            0xff00afff,
            0xff00d700,
            0xff00d75f,
            0xff00d787,
            0xff00d7af,
            0xff00d7d7,
            0xff00d7ff,
            0xff00ff00,
            0xff00ff5f,
            0xff00ff87,
            0xff00ffaf,
            0xff00ffd7,
            0xff00ffff,
            0xff5f0000,
            0xff5f005f,
            0xff5f0087,
            0xff5f00af,
            0xff5f00d7,
            0xff5f00ff,
            0xff5f5f00,
            0xff5f5f5f,
            0xff5f5f87,
            0xff5f5faf,
            0xff5f5fd7,
            0xff5f5fff,
            0xff5f8700,
            0xff5f875f,
            0xff5f8787,
            0xff5f87af,
            0xff5f87d7,
            0xff5f87ff,
            0xff5faf00,
            0xff5faf5f,
            0xff5faf87,
            0xff5fafaf,
            0xff5fafd7,
            0xff5fafff,
            0xff5fd700,
            0xff5fd75f,
            0xff5fd787,
            0xff5fd7af,
            0xff5fd7d7,
            0xff5fd7ff,
            0xff5fff00,
            0xff5fff5f,
            0xff5fff87,
            0xff5fffaf,
            0xff5fffd7,
            0xff5fffff,
            0xff870000,
            0xff87005f,
            0xff870087,
            0xff8700af,
            0xff8700d7,
            0xff8700ff,
            0xff875f00,
            0xff875f5f,
            0xff875f87,
            0xff875faf,
            0xff875fd7,
            0xff875fff,
            0xff878700,
            0xff87875f,
            0xff878787,
            0xff8787af,
            0xff8787d7,
            0xff8787ff,
            0xff87af00,
            0xff87af5f,
            0xff87af87,
            0xff87afaf,
            0xff87afd7,
            0xff87afff,
            0xff87d700,
            0xff87d75f,
            0xff87d787,
            0xff87d7af,
            0xff87d7d7,
            0xff87d7ff,
            0xff87ff00,
            0xff87ff5f,
            0xff87ff87,
            0xff87ffaf,
            0xff87ffd7,
            0xff87ffff,
            0xffaf0000,
            0xffaf005f,
            0xffaf0087,
            0xffaf00af,
            0xffaf00d7,
            0xffaf00ff,
            0xffaf5f00,
            0xffaf5f5f,
            0xffaf5f87,
            0xffaf5faf,
            0xffaf5fd7,
            0xffaf5fff,
            0xffaf8700,
            0xffaf875f,
            0xffaf8787,
            0xffaf87af,
            0xffaf87d7,
            0xffaf87ff,
            0xffafaf00,
            0xffafaf5f,
            0xffafaf87,
            0xffafafaf,
            0xffafafd7,
            0xffafafff,
            0xffafd700,
            0xffafd75f,
            0xffafd787,
            0xffafd7af,
            0xffafd7d7,
            0xffafd7ff,
            0xffafff00,
            0xffafff5f,
            0xffafff87,
            0xffafffaf,
            0xffafffd7,
            0xffafffff,
            0xffd70000,
            0xffd7005f,
            0xffd70087,
            0xffd700af,
            0xffd700d7,
            0xffd700ff,
            0xffd75f00,
            0xffd75f5f,
            0xffd75f87,
            0xffd75faf,
            0xffd75fd7,
            0xffd75fff,
            0xffd78700,
            0xffd7875f,
            0xffd78787,
            0xffd787af,
            0xffd787d7,
            0xffd787ff,
            0xffd7af00,
            0xffd7af5f,
            0xffd7af87,
            0xffd7afaf,
            0xffd7afd7,
            0xffd7afff,
            0xffd7d700,
            0xffd7d75f,
            0xffd7d787,
            0xffd7d7af,
            0xffd7d7d7,
            0xffd7d7ff,
            0xffd7ff00,
            0xffd7ff5f,
            0xffd7ff87,
            0xffd7ffaf,
            0xffd7ffd7,
            0xffd7ffff,
            0xffff0000,
            0xffff005f,
            0xffff0087,
            0xffff00af,
            0xffff00d7,
            0xffff00ff,
            0xffff5f00,
            0xffff5f5f,
            0xffff5f87,
            0xffff5faf,
            0xffff5fd7,
            0xffff5fff,
            0xffff8700,
            0xffff875f,
            0xffff8787,
            0xffff87af,
            0xffff87d7,
            0xffff87ff,
            0xffffaf00,
            0xffffaf5f,
            0xffffaf87,
            0xffffafaf,
            0xffffafd7,
            0xffffafff,
            0xffffd700,
            0xffffd75f,
            0xffffd787,
            0xffffd7af,
            0xffffd7d7,
            0xffffd7ff,
            0xffffff00,
            0xffffff5f,
            0xffffff87,
            0xffffffaf,
            0xffffffd7,
            0xffffffff,

        // 24 grey scale ramp
            0xff080808,
            0xff121212,
            0xff1c1c1c,
            0xff262626,
            0xff303030,
            0xff3a3a3a,
            0xff444444,
            0xff4e4e4e,
            0xff585858,
            0xff626262,
            0xff6c6c6c,
            0xff767676,
            0xff808080,
            0xff8a8a8a,
            0xff949494,
            0xff9e9e9e,
            0xffa8a8a8,
            0xffb2b2b2,
            0xffbcbcbc,
            0xffc6c6c6,
            0xffd0d0d0,
            0xffdadada,
            0xffe4e4e4,
            0xffeeeeee
    };

    private final static int sCursorColor = 0xff808080;
    static final ColorScheme defaultColorScheme =
            new ColorScheme(0xffcccccc, 0xff000000);

    private final Paint mCursorPaint;
    private final Paint mCursorStrokePaint;
    private final Path mShiftCursor;
    private final Path mAltCursor;
    private final Path mCtrlCursor;
    private final Path mFnCursor;
    private RectF mTempSrc;
    private RectF mTempDst;
    private Matrix mScaleMatrix;
    private float mLastCharWidth;
    private float mLastCharHeight;
    private static final Matrix.ScaleToFit mScaleType = Matrix.ScaleToFit.FILL;


    public BaseTextRenderer(ColorScheme scheme) {
        if (scheme == null) {
            scheme = defaultColorScheme;
        }
        setDefaultColors(scheme.getForeColor(), scheme.getBackColor());

        mCursorPaint = new Paint();
        mCursorPaint.setColor(sCursorColor);
        mCursorPaint.setXfermode(new PixelXorXfermode(~sCursorColor));
        mCursorPaint.setAntiAlias(true);

        mCursorStrokePaint = new Paint(mCursorPaint);
        mCursorStrokePaint.setStrokeWidth(0.1f);
        mCursorStrokePaint.setStyle(Paint.Style.STROKE);

        mShiftCursor = new Path();
        mShiftCursor.lineTo(0.5f, 0.33f);
        mShiftCursor.lineTo(1.0f, 0.0f);

        mAltCursor = new Path();
        mAltCursor.moveTo(0.0f, 1.0f);
        mAltCursor.lineTo(0.5f, 0.66f);
        mAltCursor.lineTo(1.0f, 1.0f);

        mCtrlCursor = new Path();
        mCtrlCursor.moveTo(0.0f, 0.25f);
        mCtrlCursor.lineTo(1.0f, 0.5f);
        mCtrlCursor.lineTo(0.0f, 0.75f);

        mFnCursor = new Path();
        mFnCursor.moveTo(1.0f, 0.25f);
        mFnCursor.lineTo(0.0f, 0.5f);
        mFnCursor.lineTo(1.0f, 0.75f);

        // For creating the transform when the terminal resizes
        mTempSrc = new RectF();
        mTempSrc.set(0.0f, 0.0f, 1.0f, 1.0f);
        mTempDst = new RectF();
        mScaleMatrix = new Matrix();
    }

    public void setReverseVideo(boolean reverseVideo) {
        mReverseVideo = reverseVideo;
    }

    private void setDefaultColors(int forePaintColor, int backPaintColor) {
        mPalette = cloneDefaultColors();
        mPalette[TextStyle.ciForeground] = forePaintColor;
        mPalette[TextStyle.ciBackground] = backPaintColor;
        mPalette[TextStyle.ciCursor] = sCursorColor;
    }

    private static int[] cloneDefaultColors() {
        int length = sXterm256Paint.length;
        int[] clone = new int[TextStyle.ciColorLength];
        System.arraycopy(sXterm256Paint, 0, clone, 0, length);
        return clone;
    }

    protected void drawCursorImp(Canvas canvas, float x, float y, float charWidth, float charHeight,
            int cursorMode) {
        if (charWidth != mLastCharWidth || charHeight != mLastCharHeight) {
            mLastCharWidth = charWidth;
            mLastCharHeight = charHeight;
            mTempDst.set(0.0f, 0.0f, charWidth, charHeight);
            mScaleMatrix.setRectToRect(mTempSrc, mTempDst, mScaleType);
        }
        canvas.save();
        canvas.translate(x, y - charHeight);
        canvas.clipRect(0, 0, charWidth, charHeight);
        canvas.drawPaint(mCursorPaint);

        if (cursorMode != 0) {
            canvas.concat(mScaleMatrix);
            drawCursorHelper(canvas, mShiftCursor, cursorMode, MODE_SHIFT_SHIFT);
            drawCursorHelper(canvas, mAltCursor, cursorMode, MODE_ALT_SHIFT);
            drawCursorHelper(canvas, mCtrlCursor, cursorMode, MODE_CTRL_SHIFT);
            drawCursorHelper(canvas, mFnCursor, cursorMode, MODE_FN_SHIFT);
        }
        canvas.restore();
    }

    private void drawCursorHelper(Canvas canvas, Path path, int mode, int shift) {
        switch ((mode >> shift) & MODE_MASK) {
        case MODE_ON:
            canvas.drawPath(path, mCursorStrokePaint);
            break;
        case MODE_LOCKED:
            canvas.drawPath(path, mCursorPaint);
            break;
        }
    }
}

package com.termx;

/**
 * A multi-thread-safe produce-consumer byte array.
 * Only allows one producer and one consumer.
 */

public class ByteQueue {
    public ByteQueue(int size) {
        mBuffer = new byte[size];
    }

    public int getBytesAvailable() {
        synchronized(this) {
            return mStoredBytes;
        }
    }

    public int read(byte[] buffer, int offset, int length)
        throws InterruptedException {
        if (length + offset > buffer.length) {
            throw
                new IllegalArgumentException("length + offset > buffer.length");
        }
        if (length < 0) {
            throw
            new IllegalArgumentException("length < 0");

        }
        if (length == 0) {
            return 0;
        }
        synchronized(this) {
            while (mStoredBytes == 0) {
                wait();
            }
            int totalRead = 0;
            int bufferLength = mBuffer.length;
            boolean wasFull = bufferLength == mStoredBytes;
            while (length > 0 && mStoredBytes > 0) {
                int oneRun = Math.min(bufferLength - mHead, mStoredBytes);
                int bytesToCopy = Math.min(length, oneRun);
                System.arraycopy(mBuffer, mHead, buffer, offset, bytesToCopy);
                mHead += bytesToCopy;
                if (mHead >= bufferLength) {
                    mHead = 0;
                }
                mStoredBytes -= bytesToCopy;
                length -= bytesToCopy;
                offset += bytesToCopy;
                totalRead += bytesToCopy;
            }
            if (wasFull) {
                notify();
            }
            return totalRead;
        }
    }

    public void write(byte[] buffer, int offset, int length)
    throws InterruptedException {
        if (length + offset > buffer.length) {
            throw
                new IllegalArgumentException("length + offset > buffer.length");
        }
        if (length < 0) {
            throw
            new IllegalArgumentException("length < 0");

        }
        if (length == 0) {
            return;
        }
        synchronized(this) {
            int bufferLength = mBuffer.length;
            boolean wasEmpty = mStoredBytes == 0;
            while (length > 0) {
                while(bufferLength == mStoredBytes) {
                    wait();
                }
                int tail = mHead + mStoredBytes;
                int oneRun;
                if (tail >= bufferLength) {
                    tail = tail - bufferLength;
                    oneRun = mHead - tail;
                } else {
                    oneRun = bufferLength - tail;
                }
                int bytesToCopy = Math.min(oneRun, length);
                System.arraycopy(buffer, offset, mBuffer, tail, bytesToCopy);
                offset += bytesToCopy;
                mStoredBytes += bytesToCopy;
                length -= bytesToCopy;
            }
            if (wasEmpty) {
                notify();
            }
        }
    }

    private byte[] mBuffer;
    private int mHead;
    private int mStoredBytes;
}

package com.termx;

/**
 * A class describing a color scheme for a 16-color VT100 terminal.
 * <p>
 * A 16-color VT100 has two separate color maps, one for foreground colors and
 * one for background colors.  Each one contains eight colors, which are
 * traditionally found in the following order:
 * <p>
 * <code>{ black, red, green, yellow, blue, magenta, cyan, white }</code>
 * <p>
 * In addition, each of the foreground colors has a corresponding "bright"
 * version.  Traditionally, the "dim" white is actually a light gray, while
 * the "bright" black is a dark gray color.
 * <p>
 * {@link EmulatorView} supports limited changes to the default color maps
 * via the color scheme mechanism.  Passing a <code>ColorScheme</code> to
 * {@link EmulatorView#setColorScheme setColorScheme} will cause the
 * foreground color with map index <code>foreColorIndex</code> to be replaced
 * with the provided <code>foreColor</code>, and the background color with map
 * index <code>backColorIndex</code> to be replaced with the provided
 * <code>backColor</code>.  The provided colors will then become the default
 * foreground and background colors for the <code>EmulatorView</code>.
 *
 * @see EmulatorView#setColorScheme
 */

public class ColorScheme {
    private int foreColor;
    private int backColor;

    /**
     * Creates a <code>ColorScheme</code> object.
     *
     * @param foreColor The foreground color as an ARGB hex value.
     * @param backColor The background color as an ARGB hex value.
     */
    public ColorScheme(int foreColor, int backColor) {
        this.foreColor = foreColor;
        this.backColor = backColor;
    }

    /**
     * Creates a <code>ColorScheme</code> object from an array.
     *
     * @param scheme An integer array <code>{ foreColorIndex, foreColor,
     *               backColorIndex, backColor }</code>.
     */
    public ColorScheme(int[] scheme) {
        if (scheme.length != 2) {
            throw new IllegalArgumentException();
        }

        this.foreColor = scheme[0];
        this.backColor = scheme[1];
    }

    /**
     * @return This <code>ColorScheme</code>'s foreground color as an ARGB
     *         hex value.
     */
    public int getForeColor() {
        return foreColor;
    }

    /**
     * @return This <code>ColorScheme</code>'s background color as an ARGB
     *         hex value.
     */
    public int getBackColor() {
        return backColor;
    }
}
package com.termx;

public class GrowableIntArray {
    public GrowableIntArray(int initalCapacity) {
        mData = new int[initalCapacity];
        mLength = 0;
    }

    public void append(int i) {
        if (mLength + 1 > mData.length) {
            int newLength = Math.max((mData.length * 3) >> 1, 16);
            int[] temp = new int[newLength];
            System.arraycopy(mData, 0, temp, 0, mLength);
            mData = temp;
        }
        mData[mLength++] = i;
    }

    int length() {
        return mLength;
    }

    int at(int index) {
        return mData[index];
    }

    int[] mData;
    int mLength;
}
package com.termx;

import android.view.KeyCharacterMap;

public abstract class KeyCharacterMapCompat {
    public static final int MODIFIER_BEHAVIOR_CHORDED = 0;
    public static final int MODIFIER_BEHAVIOR_CHORDED_OR_TOGGLED = 1;

    public static KeyCharacterMapCompat wrap(Object map) {
        if (map != null) {
            if (AndroidCompat.SDK >= 11) {
                return new KeyCharacterMapApi11OrLater(map);
            }
        }
        return null;
    }

    private static class KeyCharacterMapApi11OrLater
        extends KeyCharacterMapCompat {
        private KeyCharacterMap mMap;
        public KeyCharacterMapApi11OrLater(Object map) {
            mMap = (KeyCharacterMap) map;
        }
        public int getModifierBehaviour() {
            return mMap.getModifierBehavior();
        }
    }

    public abstract int getModifierBehaviour();
}
package com.termx;

/**
 * Keycode constants and modifier masks for use with keyboard event listeners.
 * 
 * The Meta masks (ctrl, alt, shift, and meta) are used as follows:
 *     KeyEvent keyEvent = ...;
 *     boolean isCtrlPressed = (keyEvent.getMetaState() & META_CTRL_ON) != 0
 *
 * Contains the complete set of Android key codes that were defined as of the 2.3 API.
 * We could pull in the constants from the 2.3 API, but then we would need to raise the
 * SDK minVersion in the manifest. We want to keep compatibility with Android 1.6, 
 * and raising this level could result in the accidental use of a newer API.
 */
public class KeycodeConstants {

    /** Key code constant: Unknown key code. */
    public static final int KEYCODE_UNKNOWN         = 0;
    /** Key code constant: Soft Left key.
     * Usually situated below the display on phones and used as a multi-function
     * feature key for selecting a software defined function shown on the bottom left
     * of the display. */
    public static final int KEYCODE_SOFT_LEFT       = 1;
    /** Key code constant: Soft Right key.
     * Usually situated below the display on phones and used as a multi-function
     * feature key for selecting a software defined function shown on the bottom right
     * of the display. */
    public static final int KEYCODE_SOFT_RIGHT      = 2;
    /** Key code constant: Home key.
     * This key is handled by the framework and is never delivered to applications. */
    public static final int KEYCODE_HOME            = 3;
    /** Key code constant: Back key. */
    public static final int KEYCODE_BACK            = 4;
    /** Key code constant: Call key. */
    public static final int KEYCODE_CALL            = 5;
    /** Key code constant: End Call key. */
    public static final int KEYCODE_ENDCALL         = 6;
    /** Key code constant: '0' key. */
    public static final int KEYCODE_0               = 7;
    /** Key code constant: '1' key. */
    public static final int KEYCODE_1               = 8;
    /** Key code constant: '2' key. */
    public static final int KEYCODE_2               = 9;
    /** Key code constant: '3' key. */
    public static final int KEYCODE_3               = 10;
    /** Key code constant: '4' key. */
    public static final int KEYCODE_4               = 11;
    /** Key code constant: '5' key. */
    public static final int KEYCODE_5               = 12;
    /** Key code constant: '6' key. */
    public static final int KEYCODE_6               = 13;
    /** Key code constant: '7' key. */
    public static final int KEYCODE_7               = 14;
    /** Key code constant: '8' key. */
    public static final int KEYCODE_8               = 15;
    /** Key code constant: '9' key. */
    public static final int KEYCODE_9               = 16;
    /** Key code constant: '*' key. */
    public static final int KEYCODE_STAR            = 17;
    /** Key code constant: '#' key. */
    public static final int KEYCODE_POUND           = 18;
    /** Key code constant: Directional Pad Up key.
     * May also be synthesized from trackball motions. */
    public static final int KEYCODE_DPAD_UP         = 19;
    /** Key code constant: Directional Pad Down key.
     * May also be synthesized from trackball motions. */
    public static final int KEYCODE_DPAD_DOWN       = 20;
    /** Key code constant: Directional Pad Left key.
     * May also be synthesized from trackball motions. */
    public static final int KEYCODE_DPAD_LEFT       = 21;
    /** Key code constant: Directional Pad Right key.
     * May also be synthesized from trackball motions. */
    public static final int KEYCODE_DPAD_RIGHT      = 22;
    /** Key code constant: Directional Pad Center key.
     * May also be synthesized from trackball motions. */
    public static final int KEYCODE_DPAD_CENTER     = 23;
    /** Key code constant: Volume Up key.
     * Adjusts the speaker volume up. */
    public static final int KEYCODE_VOLUME_UP       = 24;
    /** Key code constant: Volume Down key.
     * Adjusts the speaker volume down. */
    public static final int KEYCODE_VOLUME_DOWN     = 25;
    /** Key code constant: Power key. */
    public static final int KEYCODE_POWER           = 26;
    /** Key code constant: Camera key.
     * Used to launch a camera application or take pictures. */
    public static final int KEYCODE_CAMERA          = 27;
    /** Key code constant: Clear key. */
    public static final int KEYCODE_CLEAR           = 28;
    /** Key code constant: 'A' key. */
    public static final int KEYCODE_A               = 29;
    /** Key code constant: 'B' key. */
    public static final int KEYCODE_B               = 30;
    /** Key code constant: 'C' key. */
    public static final int KEYCODE_C               = 31;
    /** Key code constant: 'D' key. */
    public static final int KEYCODE_D               = 32;
    /** Key code constant: 'E' key. */
    public static final int KEYCODE_E               = 33;
    /** Key code constant: 'F' key. */
    public static final int KEYCODE_F               = 34;
    /** Key code constant: 'G' key. */
    public static final int KEYCODE_G               = 35;
    /** Key code constant: 'H' key. */
    public static final int KEYCODE_H               = 36;
    /** Key code constant: 'I' key. */
    public static final int KEYCODE_I               = 37;
    /** Key code constant: 'J' key. */
    public static final int KEYCODE_J               = 38;
    /** Key code constant: 'K' key. */
    public static final int KEYCODE_K               = 39;
    /** Key code constant: 'L' key. */
    public static final int KEYCODE_L               = 40;
    /** Key code constant: 'M' key. */
    public static final int KEYCODE_M               = 41;
    /** Key code constant: 'N' key. */
    public static final int KEYCODE_N               = 42;
    /** Key code constant: 'O' key. */
    public static final int KEYCODE_O               = 43;
    /** Key code constant: 'P' key. */
    public static final int KEYCODE_P               = 44;
    /** Key code constant: 'Q' key. */
    public static final int KEYCODE_Q               = 45;
    /** Key code constant: 'R' key. */
    public static final int KEYCODE_R               = 46;
    /** Key code constant: 'S' key. */
    public static final int KEYCODE_S               = 47;
    /** Key code constant: 'T' key. */
    public static final int KEYCODE_T               = 48;
    /** Key code constant: 'U' key. */
    public static final int KEYCODE_U               = 49;
    /** Key code constant: 'V' key. */
    public static final int KEYCODE_V               = 50;
    /** Key code constant: 'W' key. */
    public static final int KEYCODE_W               = 51;
    /** Key code constant: 'X' key. */
    public static final int KEYCODE_X               = 52;
    /** Key code constant: 'Y' key. */
    public static final int KEYCODE_Y               = 53;
    /** Key code constant: 'Z' key. */
    public static final int KEYCODE_Z               = 54;
    /** Key code constant: ',' key. */
    public static final int KEYCODE_COMMA           = 55;
    /** Key code constant: '.' key. */
    public static final int KEYCODE_PERIOD          = 56;
    /** Key code constant: Left Alt modifier key. */
    public static final int KEYCODE_ALT_LEFT        = 57;
    /** Key code constant: Right Alt modifier key. */
    public static final int KEYCODE_ALT_RIGHT       = 58;
    /** Key code constant: Left Shift modifier key. */
    public static final int KEYCODE_SHIFT_LEFT      = 59;
    /** Key code constant: Right Shift modifier key. */
    public static final int KEYCODE_SHIFT_RIGHT     = 60;
    /** Key code constant: Tab key. */
    public static final int KEYCODE_TAB             = 61;
    /** Key code constant: Space key. */
    public static final int KEYCODE_SPACE           = 62;
    /** Key code constant: Symbol modifier key.
     * Used to enter alternate symbols. */
    public static final int KEYCODE_SYM             = 63;
    /** Key code constant: Explorer special function key.
     * Used to launch a browser application. */
    public static final int KEYCODE_EXPLORER        = 64;
    /** Key code constant: Envelope special function key.
     * Used to launch a mail application. */
    public static final int KEYCODE_ENVELOPE        = 65;
    /** Key code constant: Enter key. */
    public static final int KEYCODE_ENTER           = 66;
    /** Key code constant: Backspace key.
     * Deletes characters before the insertion point, unlike {@link #KEYCODE_FORWARD_DEL}. */
    public static final int KEYCODE_DEL             = 67;
    /** Key code constant: '`' (backtick) key. */
    public static final int KEYCODE_GRAVE           = 68;
    /** Key code constant: '-'. */
    public static final int KEYCODE_MINUS           = 69;
    /** Key code constant: '=' key. */
    public static final int KEYCODE_EQUALS          = 70;
    /** Key code constant: '[' key. */
    public static final int KEYCODE_LEFT_BRACKET    = 71;
    /** Key code constant: ']' key. */
    public static final int KEYCODE_RIGHT_BRACKET   = 72;
    /** Key code constant: '\' key. */
    public static final int KEYCODE_BACKSLASH       = 73;
    /** Key code constant: ';' key. */
    public static final int KEYCODE_SEMICOLON       = 74;
    /** Key code constant: ''' (apostrophe) key. */
    public static final int KEYCODE_APOSTROPHE      = 75;
    /** Key code constant: '/' key. */
    public static final int KEYCODE_SLASH           = 76;
    /** Key code constant: '@' key. */
    public static final int KEYCODE_AT              = 77;
    /** Key code constant: Number modifier key.
     * Used to enter numeric symbols.
     * This key is not Num Lock; it is more like {@link #KEYCODE_ALT_LEFT} and is
     * interpreted as an ALT key by {@link android.text.method.MetaKeyKeyListener}. */
    public static final int KEYCODE_NUM             = 78;
    /** Key code constant: Headset Hook key.
     * Used to hang up calls and stop media. */
    public static final int KEYCODE_HEADSETHOOK     = 79;
    /** Key code constant: Camera Focus key.
     * Used to focus the camera. */
    public static final int KEYCODE_FOCUS           = 80;   // *Camera* focus
    /** Key code constant: '+' key. */
    public static final int KEYCODE_PLUS            = 81;
    /** Key code constant: Menu key. */
    public static final int KEYCODE_MENU            = 82;
    /** Key code constant: Notification key. */
    public static final int KEYCODE_NOTIFICATION    = 83;
    /** Key code constant: Search key. */
    public static final int KEYCODE_SEARCH          = 84;
    /** Key code constant: Play/Pause media key. */
    public static final int KEYCODE_MEDIA_PLAY_PAUSE= 85;
    /** Key code constant: Stop media key. */
    public static final int KEYCODE_MEDIA_STOP      = 86;
    /** Key code constant: Play Next media key. */
    public static final int KEYCODE_MEDIA_NEXT      = 87;
    /** Key code constant: Play Previous media key. */
    public static final int KEYCODE_MEDIA_PREVIOUS  = 88;
    /** Key code constant: Rewind media key. */
    public static final int KEYCODE_MEDIA_REWIND    = 89;
    /** Key code constant: Fast Forward media key. */
    public static final int KEYCODE_MEDIA_FAST_FORWARD = 90;
    /** Key code constant: Mute key.
     * Mutes the microphone, unlike {@link #KEYCODE_VOLUME_MUTE}. */
    public static final int KEYCODE_MUTE            = 91;
    /** Key code constant: Page Up key. */
    public static final int KEYCODE_PAGE_UP         = 92;
    /** Key code constant: Page Down key. */
    public static final int KEYCODE_PAGE_DOWN       = 93;
    /** Key code constant: Picture Symbols modifier key.
     * Used to switch symbol sets (Emoji, Kao-moji). */
    public static final int KEYCODE_PICTSYMBOLS     = 94;   // switch symbol-sets (Emoji,Kao-moji)
    /** Key code constant: Switch Charset modifier key.
     * Used to switch character sets (Kanji, Katakana). */
    public static final int KEYCODE_SWITCH_CHARSET  = 95;   // switch char-sets (Kanji,Katakana)
    /** Key code constant: A Button key.
     * On a game controller, the A button should be either the button labeled A
     * or the first button on the upper row of controller buttons. */
    public static final int KEYCODE_BUTTON_A        = 96;
    /** Key code constant: B Button key.
     * On a game controller, the B button should be either the button labeled B
     * or the second button on the upper row of controller buttons. */
    public static final int KEYCODE_BUTTON_B        = 97;
    /** Key code constant: C Button key.
     * On a game controller, the C button should be either the button labeled C
     * or the third button on the upper row of controller buttons. */
    public static final int KEYCODE_BUTTON_C        = 98;
    /** Key code constant: X Button key.
     * On a game controller, the X button should be either the button labeled X
     * or the first button on the lower row of controller buttons. */
    public static final int KEYCODE_BUTTON_X        = 99;
    /** Key code constant: Y Button key.
     * On a game controller, the Y button should be either the button labeled Y
     * or the second button on the lower row of controller buttons. */
    public static final int KEYCODE_BUTTON_Y        = 100;
    /** Key code constant: Z Button key.
     * On a game controller, the Z button should be either the button labeled Z
     * or the third button on the lower row of controller buttons. */
    public static final int KEYCODE_BUTTON_Z        = 101;
    /** Key code constant: L1 Button key.
     * On a game controller, the L1 button should be either the button labeled L1 (or L)
     * or the top left trigger button. */
    public static final int KEYCODE_BUTTON_L1       = 102;
    /** Key code constant: R1 Button key.
     * On a game controller, the R1 button should be either the button labeled R1 (or R)
     * or the top right trigger button. */
    public static final int KEYCODE_BUTTON_R1       = 103;
    /** Key code constant: L2 Button key.
     * On a game controller, the L2 button should be either the button labeled L2
     * or the bottom left trigger button. */
    public static final int KEYCODE_BUTTON_L2       = 104;
    /** Key code constant: R2 Button key.
     * On a game controller, the R2 button should be either the button labeled R2
     * or the bottom right trigger button. */
    public static final int KEYCODE_BUTTON_R2       = 105;
    /** Key code constant: Left Thumb Button key.
     * On a game controller, the left thumb button indicates that the left (or only)
     * joystick is pressed. */
    public static final int KEYCODE_BUTTON_THUMBL   = 106;
    /** Key code constant: Right Thumb Button key.
     * On a game controller, the right thumb button indicates that the right
     * joystick is pressed. */
    public static final int KEYCODE_BUTTON_THUMBR   = 107;
    /** Key code constant: Start Button key.
     * On a game controller, the button labeled Start. */
    public static final int KEYCODE_BUTTON_START    = 108;
    /** Key code constant: Select Button key.
     * On a game controller, the button labeled Select. */
    public static final int KEYCODE_BUTTON_SELECT   = 109;
    /** Key code constant: Mode Button key.
     * On a game controller, the button labeled Mode. */
    public static final int KEYCODE_BUTTON_MODE     = 110;
    /** Key code constant: Escape key. */
    public static final int KEYCODE_ESCAPE          = 111;
    /** Key code constant: Forward Delete key.
     * Deletes characters ahead of the insertion point, unlike {@link #KEYCODE_DEL}. */
    public static final int KEYCODE_FORWARD_DEL     = 112;
    /** Key code constant: Left Control modifier key. */
    public static final int KEYCODE_CTRL_LEFT       = 113;
    /** Key code constant: Right Control modifier key. */
    public static final int KEYCODE_CTRL_RIGHT      = 114;
    /** Key code constant: Caps Lock modifier key. */
    public static final int KEYCODE_CAPS_LOCK       = 115;
    /** Key code constant: Scroll Lock key. */
    public static final int KEYCODE_SCROLL_LOCK     = 116;
    /** Key code constant: Left Meta modifier key. */
    public static final int KEYCODE_META_LEFT       = 117;
    /** Key code constant: Right Meta modifier key. */
    public static final int KEYCODE_META_RIGHT      = 118;
    /** Key code constant: Function modifier key. */
    public static final int KEYCODE_FUNCTION        = 119;
    /** Key code constant: System Request / Print Screen key. */
    public static final int KEYCODE_SYSRQ           = 120;
    /** Key code constant: Break / Pause key. */
    public static final int KEYCODE_BREAK           = 121;
    /** Key code constant: Home Movement key.
     * Used for scrolling or moving the cursor around to the start of a line
     * or to the top of a list. */
    public static final int KEYCODE_MOVE_HOME       = 122;
    /** Key code constant: End Movement key.
     * Used for scrolling or moving the cursor around to the end of a line
     * or to the bottom of a list. */
    public static final int KEYCODE_MOVE_END        = 123;
    /** Key code constant: Insert key.
     * Toggles insert / overwrite edit mode. */
    public static final int KEYCODE_INSERT          = 124;
    /** Key code constant: Forward key.
     * Navigates forward in the history stack.  Complement of {@link #KEYCODE_BACK}. */
    public static final int KEYCODE_FORWARD         = 125;
    /** Key code constant: Play media key. */
    public static final int KEYCODE_MEDIA_PLAY      = 126;
    /** Key code constant: Pause media key. */
    public static final int KEYCODE_MEDIA_PAUSE     = 127;
    /** Key code constant: Close media key.
     * May be used to close a CD tray, for example. */
    public static final int KEYCODE_MEDIA_CLOSE     = 128;
    /** Key code constant: Eject media key.
     * May be used to eject a CD tray, for example. */
    public static final int KEYCODE_MEDIA_EJECT     = 129;
    /** Key code constant: Record media key. */
    public static final int KEYCODE_MEDIA_RECORD    = 130;
    /** Key code constant: F1 key. */
    public static final int KEYCODE_F1              = 131;
    /** Key code constant: F2 key. */
    public static final int KEYCODE_F2              = 132;
    /** Key code constant: F3 key. */
    public static final int KEYCODE_F3              = 133;
    /** Key code constant: F4 key. */
    public static final int KEYCODE_F4              = 134;
    /** Key code constant: F5 key. */
    public static final int KEYCODE_F5              = 135;
    /** Key code constant: F6 key. */
    public static final int KEYCODE_F6              = 136;
    /** Key code constant: F7 key. */
    public static final int KEYCODE_F7              = 137;
    /** Key code constant: F8 key. */
    public static final int KEYCODE_F8              = 138;
    /** Key code constant: F9 key. */
    public static final int KEYCODE_F9              = 139;
    /** Key code constant: F10 key. */
    public static final int KEYCODE_F10             = 140;
    /** Key code constant: F11 key. */
    public static final int KEYCODE_F11             = 141;
    /** Key code constant: F12 key. */
    public static final int KEYCODE_F12             = 142;
    /** Key code constant: Num Lock modifier key.
     * This is the Num Lock key; it is different from {@link #KEYCODE_NUM}.
     * This key generally modifies the behavior of other keys on the numeric keypad. */
    public static final int KEYCODE_NUM_LOCK        = 143;
    /** Key code constant: Numeric keypad '0' key. */
    public static final int KEYCODE_NUMPAD_0        = 144;
    /** Key code constant: Numeric keypad '1' key. */
    public static final int KEYCODE_NUMPAD_1        = 145;
    /** Key code constant: Numeric keypad '2' key. */
    public static final int KEYCODE_NUMPAD_2        = 146;
    /** Key code constant: Numeric keypad '3' key. */
    public static final int KEYCODE_NUMPAD_3        = 147;
    /** Key code constant: Numeric keypad '4' key. */
    public static final int KEYCODE_NUMPAD_4        = 148;
    /** Key code constant: Numeric keypad '5' key. */
    public static final int KEYCODE_NUMPAD_5        = 149;
    /** Key code constant: Numeric keypad '6' key. */
    public static final int KEYCODE_NUMPAD_6        = 150;
    /** Key code constant: Numeric keypad '7' key. */
    public static final int KEYCODE_NUMPAD_7        = 151;
    /** Key code constant: Numeric keypad '8' key. */
    public static final int KEYCODE_NUMPAD_8        = 152;
    /** Key code constant: Numeric keypad '9' key. */
    public static final int KEYCODE_NUMPAD_9        = 153;
    /** Key code constant: Numeric keypad '/' key (for division). */
    public static final int KEYCODE_NUMPAD_DIVIDE   = 154;
    /** Key code constant: Numeric keypad '*' key (for multiplication). */
    public static final int KEYCODE_NUMPAD_MULTIPLY = 155;
    /** Key code constant: Numeric keypad '-' key (for subtraction). */
    public static final int KEYCODE_NUMPAD_SUBTRACT = 156;
    /** Key code constant: Numeric keypad '+' key (for addition). */
    public static final int KEYCODE_NUMPAD_ADD      = 157;
    /** Key code constant: Numeric keypad '.' key (for decimals or digit grouping). */
    public static final int KEYCODE_NUMPAD_DOT      = 158;
    /** Key code constant: Numeric keypad ',' key (for decimals or digit grouping). */
    public static final int KEYCODE_NUMPAD_COMMA    = 159;
    /** Key code constant: Numeric keypad Enter key. */
    public static final int KEYCODE_NUMPAD_ENTER    = 160;
    /** Key code constant: Numeric keypad '=' key. */
    public static final int KEYCODE_NUMPAD_EQUALS   = 161;
    /** Key code constant: Numeric keypad '(' key. */
    public static final int KEYCODE_NUMPAD_LEFT_PAREN = 162;
    /** Key code constant: Numeric keypad ')' key. */
    public static final int KEYCODE_NUMPAD_RIGHT_PAREN = 163;
    /** Key code constant: Volume Mute key.
     * Mutes the speaker, unlike {@link #KEYCODE_MUTE}.
     * This key should normally be implemented as a toggle such that the first press
     * mutes the speaker and the second press restores the original volume. */
    public static final int KEYCODE_VOLUME_MUTE     = 164;
    /** Key code constant: Info key.
     * Common on TV remotes to show additional information related to what is
     * currently being viewed. */
    public static final int KEYCODE_INFO            = 165;
    /** Key code constant: Channel up key.
     * On TV remotes, increments the television channel. */
    public static final int KEYCODE_CHANNEL_UP      = 166;
    /** Key code constant: Channel down key.
     * On TV remotes, decrements the television channel. */
    public static final int KEYCODE_CHANNEL_DOWN    = 167;
    /** Key code constant: Zoom in key. */
    public static final int KEYCODE_ZOOM_IN         = 168;
    /** Key code constant: Zoom out key. */
    public static final int KEYCODE_ZOOM_OUT        = 169;
    /** Key code constant: TV key.
     * On TV remotes, switches to viewing live TV. */
    public static final int KEYCODE_TV              = 170;
    /** Key code constant: Window key.
     * On TV remotes, toggles picture-in-picture mode or other windowing functions. */
    public static final int KEYCODE_WINDOW          = 171;
    /** Key code constant: Guide key.
     * On TV remotes, shows a programming guide. */
    public static final int KEYCODE_GUIDE           = 172;
    /** Key code constant: DVR key.
     * On some TV remotes, switches to a DVR mode for recorded shows. */
    public static final int KEYCODE_DVR             = 173;
    /** Key code constant: Bookmark key.
     * On some TV remotes, bookmarks content or web pages. */
    public static final int KEYCODE_BOOKMARK        = 174;
    /** Key code constant: Toggle captions key.
     * Switches the mode for closed-captioning text, for example during television shows. */
    public static final int KEYCODE_CAPTIONS        = 175;
    /** Key code constant: Settings key.
     * Starts the system settings activity. */
    public static final int KEYCODE_SETTINGS        = 176;
    /** Key code constant: TV power key.
     * On TV remotes, toggles the power on a television screen. */
    public static final int KEYCODE_TV_POWER        = 177;
    /** Key code constant: TV input key.
     * On TV remotes, switches the input on a television screen. */
    public static final int KEYCODE_TV_INPUT        = 178;
    /** Key code constant: Set-top-box power key.
     * On TV remotes, toggles the power on an external Set-top-box. */
    public static final int KEYCODE_STB_POWER       = 179;
    /** Key code constant: Set-top-box input key.
     * On TV remotes, switches the input mode on an external Set-top-box. */
    public static final int KEYCODE_STB_INPUT       = 180;
    /** Key code constant: A/V Receiver power key.
     * On TV remotes, toggles the power on an external A/V Receiver. */
    public static final int KEYCODE_AVR_POWER       = 181;
    /** Key code constant: A/V Receiver input key.
     * On TV remotes, switches the input mode on an external A/V Receiver. */
    public static final int KEYCODE_AVR_INPUT       = 182;
    /** Key code constant: Red "programmable" key.
     * On TV remotes, acts as a contextual/programmable key. */
    public static final int KEYCODE_PROG_RED        = 183;
    /** Key code constant: Green "programmable" key.
     * On TV remotes, actsas a contextual/programmable key. */
    public static final int KEYCODE_PROG_GREEN      = 184;
    /** Key code constant: Yellow "programmable" key.
     * On TV remotes, acts as a contextual/programmable key. */
    public static final int KEYCODE_PROG_YELLOW     = 185;
    /** Key code constant: Blue "programmable" key.
     * On TV remotes, acts as a contextual/programmable key. */
    public static final int KEYCODE_PROG_BLUE       = 186;

    public static final int LAST_KEYCODE           = KEYCODE_PROG_BLUE;

    public static final int META_ALT_ON = 2;
    public static final int META_CAPS_LOCK_ON = 0x00100000;
    public static final int META_CTRL_ON = 0x1000;
    public static final int META_SHIFT_ON = 1;
    public static final int META_CTRL_MASK = 0x7000;
    public static final int META_META_ON   = 0x00010000;
    public static final int META_META_MASK = 0x00070000;
}





package com.termx;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.Reader;
import java.io.InputStreamReader;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FilterInputStream;
import java.io.FilterOutputStream;
import java.io.PrintStream;
import android.app.Activity;
import android.content.ServiceConnection;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.ComponentName;
import android.os.Bundle;
import android.os.Binder;
import android.os.IBinder;
import android.util.Log;
import android.view.View;
import android.view.Window;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
//import java.io.StringBuffer;

import java.lang.reflect.InvocationTargetException;

import bsh.Interpreter;
import bsh.TargetError;
import bsh.UtilEvalError;
import bsh.EvalError;

//import com.termx.RunFGsvc;
/**
 * Provides a UI to launch the terminal emulator activity, connected to
 *  a local shell server.
 */
public class LaunchActivity extends Activity implements ServiceConnection {
    private static final String TAG = "LaunchActivity";
     private final String RECEIVER_FILTER="com.termx.ServiceConnection";
    static EditText termin;
    static String dataDir; private static  Context context;
    static EditText hostEntry;
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.main);
      context = this;
      //hostEntry = (EditText)findViewById(R.id.host_entry);
      //termin=(EditText)findViewById(R.id.termin);
      //dataDir=getDataDir(this);
      //termin.setText(localpath.toString()+"/bin/execpty /system/bin/ah -");//dataDir+"/bin/execpty /system/bin/sh -");
     
/* ((Button)findViewById(R.id.launch_adb)).setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                //Intent intent = new Intent(context, StartRootActivity.class);
                //intent.putExtra("state", "root");
                //startActivity(intent);
		try{
			startInterp(getInterp());//hostEntry.getText().toString());
		}catch(Exception e){
			Log.e(TAG,"startadb<OnClick>: "+e.getMessage());
		}
         }});
        ((Button)findViewById(R.id.launchLocal)).setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
	try{
  Class TermActivity=((ClassLoader)this.getClass().getClassLoader()).loadClass("TermActivity");
                Intent intent = new Intent(context, TermActivity);
		intent.putExtra("state",termin.getText().toString());
                startActivity(intent);
}catch(Exception e){}
        }});
*/ 
      adbs();
        setupDirs();
    }

    /**
     * Stuff to grab the 'execpty' binary for this architecture and unpack it
     * into bin/ under our data directory.  See TermActivity to see how we use
     * this program.
     */
    private void setupDirs() {
        File binDir = new File(localpath, "bin");
        if (!binDir.exists()) {
            try {
                binDir.mkdir();
                chmod("0775", binDir.getAbsolutePath());
        chmod("0775","/data/data/com.termx");
            } catch (Exception e) {
            }
        }
         
       // setupFiles(binDir,"execpty");
       // setupFiles(libDir,"libexecpty.so");
     }
        /**
         * NB: If you actually plan on deploying an app which ships a binary
         * this way, you will want to implement versioning of the binary so
         * that you aren't writing it out every time the app is run.
         */
   private boolean setupFiles(File dir,String file){
        File binary = new File(dir, file);
        try {
            InputStream src = getAssets().open(file);
            FileOutputStream dst = new FileOutputStream(binary);
            copyStream(dst, src);
            chmod("0555", binary.getAbsolutePath());
        } catch (Exception e) {
         return(false);
	}
       return(true);
    }

    private String getArch() {
        /* Returns the value of uname -m */
        String machine = System.getProperty("os.arch");
        Log.d(TAG, "os.arch is " + machine);

        /* Convert machine name to our arch identifier */
        if (machine.matches("armv[0-9]+(tej?)?l")) {
            return "arm";
        } else if (machine.matches("i[3456]86")) {
            return "x86";
        } else if (machine.equals("OS_ARCH")) {
            /* This is what API < 5 devices seem to return.  Presumably all
               of these are ARM devices. */
            return "arm";
        } else {
            /* Result is correct for mips, and this is probably the best thing
               to do for an unknown arch */
            return machine;
        }
    }

    private void copyStream(OutputStream dst, InputStream src) throws IOException {
        byte[] buffer = new byte[4096];
        int bytesRead = 0;
        while ((bytesRead = src.read(buffer)) >= 0) {
            dst.write(buffer, 0, bytesRead);
        }
        dst.close();
    }

    private void chmod(String... args) throws IOException {
        String[] cmdline = new String[args.length + 2];
        cmdline[0] = "/system/bin/toolbox";cmdline[1]="chmod";
        System.arraycopy(args, 0, cmdline, 1, args.length);
        new ProcessBuilder(cmdline).start();
    }
 
 @Override public void onServiceConnected(ComponentName componentName,IBinder service){
  _svc=((RunFGsvc.RBinder)service).service;
  _svc._ctx=(Context)this;
  _svc._mainInterp=_mainInterp;
 }
 @Override public void onServiceDisconnected(ComponentName componentName){
  //super.onServiceDisconnected();//return(null);
 }
 @Override public void onStart(){
  super.onStart();
  registerReceiver(rbcr,new IntentFilter(RECEIVER_FILTER));
 }
 @Override public void onStop(){
  super.onStart();
 }
 private Window _currentWin;
 private final BroadcastReceiver rbcr=new BroadcastReceiver(){
 @Override public void onReceive(Context ctx,Intent itnt){
  String newtitle=itnt.getStringExtra("title");
  String newcmd=itnt.getStringExtra("cmd");
  //window cw=(Activity)context.getWindow();
  //if(_currentWin!=cw && cw!=null)
  // _currentWin=cw;
 }
 };
private Thread _bshThread; private RunFGsvc  _svc;
public String commanderr;public String localpath;
private Interpreter _mainInterp;public Process _shpr;

 private String startscript;
 public  InputStreamReader tin;
 public BufferedOutputStream tout;
 public BufferedOutputStream terr;
 private void adbs() {
  Interpreter _lInterp;
commanderr=""; localpath="/data/data/com.termx";
  File shfile=new File(localpath+"/"+"start.sh");
  try{
     if(!shfile.exists()){ FileOutputStream shwr=new FileOutputStream(shfile);shwr.write(("for a in "+localpath+"/*; do chmod 777 $a $a/*; done").getBytes());shwr.close(); }
   }catch(IOException e){}
   try{ ProcessBuilder shex=new ProcessBuilder(new String[]{"/system/bin/sh",localpath+"/start.sh"});_shpr=shex.start();
    }catch(Exception e){}
 String[] assets=new String[]{"start.bsh","start.sh"};
 for(int a=0;a<assets.length;a++){File ass=new File(localpath+"/"+assets[a]);
 if(!ass.exists()){
 try{ 
  InputStream src=getAssets().open(assets[a]); 
 FileOutputStream dst=new FileOutputStream(ass);
 byte[] buf=new byte[2048]; int read=0; while((read=src.read(buf))>0)dst.write(buf,0,read);
 dst.close();
 }catch(IOException e){} } }
 try { File _sf=new File(localpath+"/start.bsh");
StringBuffer sb=new StringBuffer(); int l=0; byte[] buf=new byte[2048]; FileInputStream	bsi=new FileInputStream(_sf);for(;l>=1;){l=bsi.read(buf,0,2048);sb.append(new String(buf,0,l));}
startscript=new String(sb);
}catch(IOException e) { commanderr+=";"+e.toString(); startscript="";}
   //  try{
	_lInterp=getInterp();
    if(_lInterp==null)
      _lInterp=new Interpreter(null,null,null,false,null,null,"adbsMain");
   try{
   _lInterp.set("_ctx",this);
  _lInterp.eval(startscript,_lInterp.getNameSpace());
  startInterp(_lInterp);
   }catch(EvalError e){}//commanderr+=", "+e.getMessage();}
    //} 
//startForegroundService(new Intent(this,TermuxService.class));
     }
 
//                        Bundle bundle = getIntent().getExtras();
	 public Interpreter getInterp() { return _mainInterp; }
  private void startInterp(Interpreter interp){
   if(interp==null)interp=getInterp();
  if(interp==null)interp=new Interpreter(null,null,null,false,null,null,"adbs"); 
    _bshThread=new bshThread();
    _bshThread.start();
    if(_mainInterp==null)_mainInterp=interp;
  }
 
  class bshThread extends Thread {
   public Interpreter bshInterp;
   private PrintStream Lout;
 @Override public void run(){
 InputStreamReader Lin=tin;if(tout!=null) Lout=new PrintStream(tout);
 bshInterp=getInterp();BufferedOutputStream Mout=null;FilterInputStream Min;boolean fail=false;
 try { Object bos=(Object)bshInterp.get("_stdout");Lout=new PrintStream((Mout=new BufferedOutputStream((OutputStream)bos))); fail=false; } catch(Exception e){fail=true;}
  if(fail){
 Log.e("abstrsctind.root","Failed bshInterp.get(_stdout);RevertingToDefault");
   if(Mout==null) try{
  Lout=new PrintStream((Mout=new BufferedOutputStream((OutputStream)new FileOutputStream(new File(localpath,"fifo"))))); 
  fail=false;
 } catch(IOException e){ fail=true;}
  else Lout=new PrintStream(Mout);//new FilterOutputStream(
 }
if(fail && tout!=null)Lout=new PrintStream(tout);
 try{
  bshInterp.set("_stdout",Lout);
 }catch(EvalError e){}
 System.setOut(Lout);
 bshInterp.setOut((PrintStream)Lout);
 fail=false;
 try { Object bis=(Object)bshInterp.get("_stdin"); if(bis!=null){Lin=new InputStreamReader(new BufferedInputStream((InputStream)bis));fail=false;}else fail=true; } catch(EvalError e){if(Lin==null)fail=true;}catch(Exception e){fail=true;}
 if(fail){
Log.e("com.termx","Failed bshInterp.get(_stdin);evertingToDefault");
 try{
 Lin=new InputStreamReader((InputStream)(Min=new BufferedInputStream((InputStream)new FileInputStream(new File(localpath,"ifife")))));fail=false; 
}catch(IOException e){fail=true; }
 }
 if(fail && tin!=null)Lin=tin;
 try{
  bshInterp.set("_stdin",Lin);
 }catch(EvalError e){}
while(true){
 try{bshInterp.eval((Reader)Lin,bshInterp.getNameSpace(),"adbsMain");
 }catch(EvalError e){commanderr+=e.toString();}catch(Exception e){
Object o;if(e instanceof InvocationTargetException){
o=((InvocationTargetException)e).getTargetException();commanderr+="; "+o.toString();}
  }
 }
  }}
}
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * aapt tool from the resource data it found.  It
 * should not be modified by hand.
 */

package com.termx;

public final class R {
    public static final class attr {
    }
    public static final class id {
        public static final int content=0x7f050003;
        public static final int emulatorView=0x7f050009;
        public static final int help=0x7f050000;
        public static final int host=0x7f050001;
        public static final int host_entry=0x7f050004;
        public static final int kill=0x7f050006;
        public static final int launchLocal=0x7f050008;
        public static final int launch_adb=0x7f050005;
        public static final int status=0x7f050002;
        public static final int termin=0x7f050007;
    }
    public static final class layout {
        public static final int launch_activity=0x7f020000;
        public static final int main=0x7f020001;
        public static final int term_activity=0x7f020002;
    }
    public static final class string {
        public static final int adb_host=0x7f040004;
        public static final int app_name=0x7f040000;
        /**  This is a better demo, but towel.blinkenlights.nl is more fun :) 
         */
        public static final int default_host=0x7f040008;
        public static final int entry_send=0x7f040005;
        public static final int help=0x7f040007;
        public static final int kill_adbd=0x7f040003;
        public static final int launch_adb=0x7f040002;
        public static final int launch_term=0x7f040001;
        public static final int start=0x7f040006;
        public static final int status=0x7f040009;
        public static final int termcmd=0x7f04000a;
    }
    public static final class xml {
        public static final int usb_accessory_filter=0x7f030000;
    }
}



package com.termx;

import android.app.Notification;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.view.Window;
import android.os.IBinder;
import android.os.Binder;



public class RunFGsvc extends Service {
	private final String SERVICE_NAME="runFgSvc";
	private final int SERVICE_ID=1101101;
	private Intent _intent;private Notification.Builder notifyBuild;
 private final String RUNFGSVC_CMD="com.termx.RunFGsvc_cmd";
 private Process _svcpr; private String[] _svccmd; private boolean _started=false;
 public static Object _mainInterp; public static Context _ctx;
	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
	 if(_started==false || startId==SERVICE_ID){
          _svccmd=intent.getStringArrayExtra(RUNFGSVC_CMD);
	  notifyBuild = new Notification.Builder(this)
			.setPriority(Notification.PRIORITY_MIN)
			.setSmallIcon(android.R.color.transparent);
			//.setContentTitle(getString(R.string.running))
			//.setContentText(getString())
	  this.startForeground(SERVICE_ID,notifyBuild.build());
          try{
            _svcpr=(new ProcessBuilder(_svccmd)).start();
          }catch(Exception e){}
	  (_intent=new Intent(this,TermActivity.class)).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	  startActivity(_intent);
         }
	   return START_NOT_STICKY;
	}
    class RBinder extends Binder {
      public final RunFGsvc service = RunFGsvc.this;
    }
    private final IBinder rbinder=new RBinder();
	@Override
	public void onDestroy() {
		super.onDestroy();
	//	stopForeground(true);
	}
	
	@Override
	public IBinder onBind(Intent p1) {
		return rbinder;
	}
private Window _currentWin;

}

package com.termx;

import com.termx.GrowableIntArray;
/**
 * An abstract screen interface. A terminal screen stores lines of text. (The
 * reason to abstract it is to allow different implementations, and to hide
 * implementation details from clients.)
 */
interface Screen {

    /**
     * Set line wrap flag for a given row. Affects how lines are logically
     * wrapped when changing screen size or converting to a transcript.
     */
    void setLineWrap(int row);

    /**
     * Store a Unicode code point into the screen at location (x, y)
     *
     * @param x X coordinate (also known as column)
     * @param y Y coordinate (also known as row)
     * @param codePoint Unicode code point to store
     * @param style the text style
     */
    void set(int x, int y, int codePoint, int style);

    /**
     * Store byte b into the screen at location (x, y)
     *
     * @param x X coordinate (also known as column)
     * @param y Y coordinate (also known as row)
     * @param b ASCII character to store
     * @param style the text style
     */
    void set(int x, int y, byte b, int style);

    /**
     * Scroll the screen down one line. To scroll the whole screen of a 24 line
     * screen, the arguments would be (0, 24).
     *
     * @param topMargin First line that is scrolled.
     * @param bottomMargin One line after the last line that is scrolled.
     * @param style the style for the newly exposed line.
     */
    void scroll(int topMargin, int bottomMargin, int style);

    /**
     * Block copy characters from one position in the screen to another. The two
     * positions can overlap. All characters of the source and destination must
     * be within the bounds of the screen, or else an InvalidParemeterException
     * will be thrown.
     *
     * @param sx source X coordinate
     * @param sy source Y coordinate
     * @param w width
     * @param h height
     * @param dx destination X coordinate
     * @param dy destination Y coordinate
     */
    void blockCopy(int sx, int sy, int w, int h, int dx, int dy);

    /**
     * Block set characters. All characters must be within the bounds of the
     * screen, or else and InvalidParemeterException will be thrown. Typically
     * this is called with a "val" argument of 32 to clear a block of
     * characters.
     *
     * @param sx source X
     * @param sy source Y
     * @param w width
     * @param h height
     * @param val value to set.
     * @param style the text style
     */
    void blockSet(int sx, int sy, int w, int h, int val, int style);

    /**
     * Get the contents of the transcript buffer as a text string.
     *
     * @return the contents of the transcript buffer.
     */
    String getTranscriptText();

    /**
     * Get the contents of the transcript buffer as a text string with color
     * information.
     *
     * @param colors A GrowableIntArray which will hold the colors.
     * @return the contents of the transcript buffer.
     */
    String getTranscriptText(GrowableIntArray colors);

    /**
     * Get the selected text inside transcript buffer as a text string.
     * @param x1 Selection start
     * @param y1 Selection start
     * @param x2 Selection end
     * @param y2 Selection end
     * @return the contents of the transcript buffer.
     */
    String getSelectedText(int x1, int y1, int x2, int y2);

    /**
     * Get the selected text inside transcript buffer as a text string with
     * color information.
     *
     * @param colors A StringBuilder which will hold the colors.
     * @param x1 Selection start
     * @param y1 Selection start
     * @param x2 Selection end
     * @param y2 Selection end
     * @return the contents of the transcript buffer.
     */
    String getSelectedText(GrowableIntArray colors, int x1, int y1, int x2, int y2);

    /**
     * Get the number of "active" (in-use) screen rows, including any rows in a
     * scrollback buffer.
     */
    int getActiveRows();

    /**
     * Try to resize the screen without losing its contents.
     *
     * @param columns
     * @param rows
     * @param cursor An int[2] containing the current cursor position
     *               { col, row }.  If the resize succeeds, the array will be
     *               updated to reflect the new location.
     * @return Whether the resize succeeded. If the operation fails, save the
     *         contents of the screen and then use the standard resize.
     */
    boolean fastResize(int columns, int rows, int[] cursor);

    /**
     * Resize the screen
     * @param columns
     * @param rows
     * @param style
     */
    void resize(int columns, int rows, int style);
}
package com.termx;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import android.app.Activity;
import android.content.Intent;
import android.content.Context;
import android.os.Bundle;
import android.util.Log;
import android.widget.Toast;
import android.hardware.usb.*;

public class StartRootActivity extends Activity {

 private static final String TAG = "StartRootActivity";
 Process process = null;
 Process process1 = null;
 DataOutputStream os = null;
 DataInputStream is = null;
 UsbManager mUSBManager=null; 
 private Intent rootsvc=null;
 String host=null;

 @Override
 public void onCreate (Bundle savedInstanceState) {
  super.onCreate (savedInstanceState);
  setContentView (R.layout.main);
 }
 public void usb_host(){
  mUSBManager = (UsbManager)getSystemService(Context.USB_SERVICE);
  //UsbAccessory ac=(UsbAccessory)rootsvc.getParceableExtra(UsbManager.EXTRA_ACCESSORY); 
 }
 public void spawn(String[] cmd) {
  try {
   host=LaunchActivity.hostEntry.getText().toString();
   process = new ProcessBuilder(host).start(); 
   process.redirectErrorOutput(true);
   os = new DataOutputStream (process.getOutputStream ());
   is = new DataInputStream (process.getInputStream ());
   os.flush();
   process.waitFor();
   Toast.makeText(this,is.readUTF(),120).show();//status,
   if (os != null) {
    os.close ();
   }
   if (is != null) {
    is.close ();
   }
   process.destroy ();
  }  catch (Exception e) {
   Log.e(TAG, "StartRootActivity<onCreate>: "+ e.getMessage());
  }
 }
}  
  
 
 /*common permissions in AndroidManifest.xml
 
 android.permission.ACCESS_CHECKIN_PROPERTIES
 	Allows read and write access to the "properties" table in the checkin
 database, change the value can be modified Upload
 android.permission.ACCESS_COARSE_LOCATION
 	Allows a program to access CellID or WiFi hotspots to get a rough location
 android.permission.ACCESS_FINE_LOCATION
 	Allows a program to access the excellent location (such as GPS)
 android.permission.ACCESS_LOCATION_EXTRA_COMMANDS
 	Allows application to access extra location provider commands
android.permission.ACCESS_MOCK_LOCATION
	Allows the program to create mock location providers for testing
android.permission.ACCESS_NETWORK_STATE
	Allow programs to access information about the GSM network
android.permission.ACCESS_SURFACE_FLINGER
	Allows the program to use SurfaceFlinger level features
android.permission.ACCESS_WIFI_STATE
	Allows the program to access the Wi-Fi network status information
android.permission.ADD_SYSTEM_SERVICE
	An application to publish system-level services
android.permission.BATTERY_STATS
	Allows the program to update the phone battery statistics
android.permission.BLUETOOTH
	Allows the program to connect to a paired Bluetooth devices
android.permission.BLUETOOTH_ADMIN
	Allows the program to the discovery and pairing Bluetooth devices
android.permission.BRICK
	Request to be able to disable the device (very dangerous
android.permission.BROADCAST_PACKAGE_REMOVED
	Allows an application to broadcast a notification that an application
	 package has been removed.
android.permission.BROADCAST_STICKY
	Allow a program broadcast common intents
android.permission.CALL_PHONE
	Allows an application to initiate a phone call without user
	 confirmation is required through a dial-up user interface
android.permission.CALL_PRIVILEGED
	Allow a program to call any number, including emergency numbers
	 without going through a dial-up user interface requires the user to confirm
android.permission.CAMERA
	Request access to the use of photographic equipment
android.permission.CHANGE_COMPONENT_ENABLED_STATE
	Allows an application to change whether a component or other enabled
	 or disabled
android.permission.CHANGE_CONFIGURATION
	Allows an application to modify the current settings, such as localization
*/

package com.termx;

/**
 * Utility class for dealing with text style lines.
 *
 * We pack color and formatting information for a particular character into an
 * int -- see the TextStyle class for details.  The simplest way of storing
 * that information for a screen row would be to use an array of int -- but
 * given that we only use the lower three bytes of the int to store information,
 * that effectively wastes one byte per character -- nearly 8 KB per 100 lines
 * with an 80-column transcript.
 *
 * Instead, we use an array of bytes and store the bytes of each int
 * consecutively in big-endian order.
 */
final class StyleRow {
    private int mStyle;
    private int mColumns;
    /** Initially null, will be allocated when needed. */
    private byte[] mData;

    StyleRow(int style, int columns) {
        mStyle = style;
        mColumns = columns;
    }

    void set(int column, int style) {
        if (style == mStyle && mData == null) {
            return;
        }
        ensureData();
        setStyle(column, style);
    }

    int get(int column) {
        if (mData == null) {
            return mStyle;
        }
        return getStyle(column);
    }

    boolean isSolidStyle() {
        return mData == null;
    }

    int getSolidStyle() {
        if (mData != null) {
            throw new IllegalArgumentException("Not a solid style");
        }
        return mStyle;
    }

    void copy(int start, StyleRow dst, int offset, int len) {
        // fast case
        if (mData == null && dst.mData == null && start == 0 && offset == 0
                && len == mColumns) {
            dst.mStyle = mStyle;
            return;
        }
        // There are other potentially fast cases, but let's just treat them
        // all the same for simplicity.
        ensureData();
        dst.ensureData();
        System.arraycopy(mData, 3*start, dst.mData, 3*offset, 3*len);

    }

    void ensureData() {
        if (mData == null) {
            allocate();
        }
    }

    private void allocate() {
        mData = new byte[3*mColumns];
        for (int i = 0; i < mColumns; i++) {
            setStyle(i, mStyle);
        }
    }

    private int getStyle(int column) {
        int index = 3 * column;
        byte[] line = mData;
        return line[index] & 0xff | (line[index+1] & 0xff) << 8
                | (line[index+2] & 0xff) << 16;
    }

    private void setStyle(int column, int value) {
        int index = 3 * column;
        byte[] line = mData;
        line[index] = (byte) (value & 0xff);
        line[index+1] = (byte) ((value >> 8) & 0xff);
        line[index+2] = (byte) ((value >> 16) & 0xff);
    }


}

package com.termx;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileDescriptor;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.Socket;
import java.util.Map;

import android.app.Activity;
import android.content.Intent;
import android.content.Context;
import android.view.inputmethod.InputMethodManager;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.WindowManager;
import android.view.MotionEvent;
import android.view.View;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.text.Editable;
import android.text.method.TextKeyListener;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.text.ClipboardManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;
import com.termx.ByteQueue;
import jackpal.androidterm.emulatorview.EmulatorView;
import com.termx.BaseTextRenderer;
import com.termx.KeycodeConstants;
import com.termx.UpdateCallback;
import com.termx.TermSession.FinishCallback;
//import com.termx.TermSessionExt;
import com.termx.execlib;
import com.termx.R;
import java.io.File;
import java.lang.reflect.InvocationTargetException;

import bsh.Interpreter;
import bsh.TargetError;
import bsh.UtilEvalError;
import bsh.EvalError;

abstract public class TermActivity extends Activity implements UpdateCallback {
    final private static String TAG = "TermActivity";
    private EditText mEntry;
    private EmulatorView mEmulatorView;
    private Interpreter bshInterp; 
    private termemu mTermemu;
    private TranscriptScreen mTransc;
    private ColorScheme mColors;
    public InputStream sin;
    public OutputStream sout;
    public ByteArrayInputStream bin;
    public ByteArrayOutputStream bout;
    private Process exec;
    private int mProcId;
    private int[] procId;
    private FileDescriptor mSessFd;
    private FileOutputStream mSessOut;
    private FileInputStream mSessIn;
    private boolean mSessAlert=false;
    private static final int NEW_INPUT=1;
    private static final int PROCESS_EXITED=-1;
    private static int DEFAULT_SIZE_X=52;
    private static int DEFAULT_SIZE_Y=80;
    private static int DEFAULT_BUF_SIZE=65535;
    public String procCmd;
    private FileDescriptor procFd;
    private Intent myIntent;
    private boolean shortcuts_enabled; 
    private Map<Byte,Byte[]> nd;
    private byte[] pb,lb,bb,buf;
    public boolean mIsRunning=false;
    private UpdateCallback mNotify;
    private byte[] mReceiveBuffer; 
    private ByteQueue mByteQueue;
    private Thread mPollingThread;
    private Handler mMsgHandler = new Handler(){
     public void handleMsg(Message msg){
      if (mSessAlert==false){
       mSessAlert=true; 
      }
      if (!mIsRunning){
       return;
      }
      else if (msg.what == PROCESS_EXITED) {
      // update((String)msg.obj);
      }
      if (msg.what==NEW_INPUT){
       readProcess();
      }
     }
    };
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.term_activity); 

        //mEntry.setOnEditorActionListener(new TextView.OnEditorActionListener() {
        /*public boolean onEditorAction(TextView v, int action, KeyEvent ev) {
          // Ignore enter-key-up events
          if (ev != null && ev.getAction() == KeyEvent.ACTION_UP){
            return false;
          }
	  String state=myIntent.getStringExtra("state");
          if (state.toString() == "sh") {
	   Integer keyc=ev.getKeyCode();
	   if (keyc==KeyEvent.KEYCODE_ENTER) {
	    myIntent.putExtra("state",pb.toString());//pb.decode("UTF-8")); 
	    pb=new byte[2048];
	   } else {
	    if (nd.containsKey(keyc)) {
             
	    }else{ 
	     pb[pb.length-1]=keyc.byteValue(); 
	    }
	   }
	   //return true;
	  } else {
           Editable e = (Editable) v.getText();
           // Write to the terminal session
           mSession.write(e.toString());
           mSession.write('\r');
           TextKeyListener.clear(e);
           return true;
          }
         } );
	*/

        //Button sendButton = (Button) findViewById(R.id.term_entry_send);
        //sendButton.setOnClickListener(new View.OnClickListener() {
        //    public void onClick(View v) {
                // Don't try to send something if we're not connected yet
        //         if (mSession == null) {
        //            return;
        //        }
        //        Editable e = (Editable) mEntry.getText();
        //        mSession.write(e.toString());
        //        TextKeyListener.clear(e);
        //    }
        //});

        /**
         * EmulatorView setup.
         */
       if (mEmulatorView==null) {
         mEmulatorView = (EmulatorView) findViewById(R.id.emulatorView);
         /* Create a TermSession. */
         myIntent = getIntent();
         String sessionstate = myIntent.getStringExtra("state");
 
         if (!sessionstate.equals(procCmd) || (mTermemu==null)){
          // Create a local shell session.
          //mColors=new ColorScheme(0xffffff00,0xff000000);
	  mTransc=new TranscriptScreen(DEFAULT_SIZE_X,DEFAULT_BUF_SIZE,DEFAULT_SIZE_Y,BaseTextRenderer.defaultColorScheme);
	  mTermemu=new termemu(mTransc, DEFAULT_SIZE_X, DEFAULT_SIZE_Y,mSessOut);
          //mTermemu.setDefaultUTF8Mode();
 	  createLocalTermSession();
          /* Attach the TermSession to the EmulatorView. */
          //mEmulatorView.attachSession(this);
         }
       }
       DisplayMetrics metrics = new DisplayMetrics();
       getWindowManager().getDefaultDisplay().getMetrics(metrics);
       mEmulatorView.setDensity(metrics);
       //execlib.setPtyWindowSize(mSessFd,metrics.rows,metrics.cols,0,0); 
       //mEmulatorView.updateSize(metrics.rows,metrics.cols);
       myIntent = getIntent();
       String sessionstate = myIntent.getStringExtra("state");
       mEmulatorView.requestFocus();
        /* That's all you have to do!  The EmulatorView will call the attached
           TermSession's initializeEmulator() automatically, once it can
           calculate the appropriate screen size for the terminal emulator. */
    }
   private void readProcess() {
     int bytesAvailable = mByteQueue.getBytesAvailable();
     int bytesToRead=Math.min(bytesAvailable, mReceiveBuffer.length);
     try {
       //int bytesRead =
	 mByteQueue.read(mReceiveBuffer, 0, bytesToRead);
       mTermemu.append(mReceiveBuffer, 0, bytesToRead);
     } catch (InterruptedException e) {
     }

     if (mNotify != null) {
       mNotify.onUpdate();
     }
   }

   @Override
   protected void onResume() {
     super.onResume();
     /* You should call this to let EmulatorView know that it's visible
       on screen. */
     mEmulatorView.onResume();
     mEmulatorView.requestFocus();
  }

  @Override
    protected void onPause() {
        /* You should call this to let EmulatorView know that it's no longer
           visible on screen. */
        mEmulatorView.onPause();
        super.onPause();
    }

    @Override
    protected void onDestroy() {
        /**
         * Finish the TermSession when we're destroyed.  This will free
         * resources, stop I/O threads, and close the I/O streams attached
         * to the session.
         *
         * For the local session, closing the streams will kill the shell; for
         * the Telnet session, it closes the network connection.
         */
        if (mEmulatorView != null) {
            //mEmulatorView=null;
        }
        if (mProcId!=null)
        execlib.hangupProcessGroup(mProcId);
       if (mSessFd!=null)
        execlib.close(mSessFd);
        mIsRunning=false;
        super.onDestroy();
    }


    @Override
    public void onBackPressed() {
      //Intent intent = new Intent(this,ActionTabActivity.class);
      //intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
      //Intent intent = new Intent(this,LaunchActivity.class);
      //startActivity(intent); 
      //mEmulatorView.requestFocus();
      //InputMethodManager imm=(InputMethodManager)getApplicationContext().getSystemService(Context.INPUT_METHOD_SERVICE);
      //imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,1);
    }
@Override
public int checkPermission(String perm,int pid,int uid){
       super.checkPermission(perm,pid,uid);
       return 1; }
@Override
protected void onActivityResult(int req,int res,Intent data){
       super.onActivityResult(req,res,data);
}
     //
     private void createNativeSession() {
         String[] args=cmd.split(" "); procCmd=cmd;
         String[] env={"HOME=/data/local/tmp"};
         procFd=execlib.createSubprocess(args[0],args,env,procId);
         mSessFd=procFd;
	 mSessIn=(FileInputStream)mSessFd.getInputStream();
	 mSessOut=(FileOutputStream)mSessFd.getOutputStream();
       }
   /*  BshInterp.set("_stdin",new BufferedInputStream(System.in));
          BshInterp.set("_stdout",new PrintStream(new BufferedOutputStream(System.out)));*/
private void startbsh(){ 
 commanderr=""; localpath=getpkgdir();
 String[] assets=new String[]{"start.bsh","start.sh"};
 for(int a=0;a<assets.length;a++){File ass=new File(localpath+"/"+assets[a]);
 if(!ass.exists()){
 try{ 
  InputStream src=getAssets().open(assets[a]); 
 FileOutputStream dst=new FileOutputStream(ass);
 byte[] buf=new byte[2048]; int read=0; while((read=src.read(buf))>0)dst.write(buf,0,read);
 dst.close();
 }catch(IOException e){} } }
  File shfile=new File(localpath+"/"+"start.sh");
  try{
     if(!shfile.exists()){ FileOutputStream shwr=new FileOutputStream(shfile);shwr.write(("for a in "+localpath+"/*; do chmod 777 $a $a/*; done").getBytes());shwr.close(); }
   }catch(IOException e){}
   try{ ProcessBuilder shex=new ProcessBuilder(new String[]{"/system/bin/sh",localpath+"/start.sh"});_shpr=shex.start();
    }catch(Exception e){}
     try{
	_mainInterp=getInterp();
	//_mainInterp.setOut(_stdout);//runtimeSession
	_mainInterp.set("_ctx",this);
   }catch(EvalError e){}//commanderr+=", "+e.getMessage();}
   started=true;
    //} 
//startForegroundService(new Intent(this,TermuxService.class));
     }
 private String startscript;
 public String commanderr;
 public  InputStreamReader tin;
 public  PrintStream tout;
 public  PrintStream terr;
 public Interpreter getInterp() {
  return _mainInterp; }
 private void startInterp(){
 localpath=getpkgdir();
 try { File _sf=new File(localpath+"/start.bsh");
StringBuffer sb=new StringBuffer(); int l=0; byte[] buf=new byte[2048]; for(FileInputStream	bsi=new FileInputStream(_sf);l>=1;){l=bsi.read(buf,0,2048);sb.append(new String(buf));}
startscript=sb.toString();
}catch(IOException e) { commanderr+=";"+e.toString(); startscript="";}
//       if(interp==null)
    _mainInterp=new Interpreter(null,null,null,false,null,null,"bshInterp");
/*try { tout=new PrintStream((OutputStream)interp.getNameSpace().get("_stdout",interp)); } catch(Exception e){ tout=new PrintStream(new BufferedOutputStream(System.out)); }
try { terr=new PrintStream((OutputStream)interp.getNameSpace().get("_stderr",interp)); } catch(Exception e){
//commanderr+=e.toString();
 terr=new PrintStream(new BufferedOutputStream(System.err)); }
       try { tin=(InputStreamReader)interp.getNameSpace().get("_stdin",interp); } catch(Exception e){//commanderr+=e.ToString();
 tin=new InputStreamReader((InputStream)System.in);
      }
 */
       try { 
 _mainInterp.eval(startscript,_mainInterp.getNameSpace());
}catch(EvalError e) { commanderr+=e.toString(); }
     _bshThread=new bshThread();
    _bshThread.start();
  }
 
  class bshThread extends Thread {
   public Interpreter bshInterp;
 @Override public void run(){
 InputStreamReader Lin; PrintStream Lout;
 bshInterp=getInterp();
 while(true){
  try{Lin=new InputStreamReader((BufferedInputStream)bshInterp.getNameSpace().get("_stdin",bshInterp));}catch(Exception e){Lin=new InputStreamReader((InputStream)System.in);}
  try{Lout=new PrintStream((OutputStream)
 bshInterp.getNameSpace().get("_stdout",bshInterp));
  }catch(Exception e){Lout=new PrintStream((OutputStream)System.out);}
  try{(new Interpreter((Reader)Lin,Lout,Lout,false,bshInterp.getNameSpace(),bshInterp,"termux")).run();}catch(Exception e){
 Object o;if(e instanceof InvocationTargetException){o=((InvocationTargetException)e).getTargetException();commanderr+="; "+o.toString();
 }else commanderr+=e.toString();}
  }
  }}
 /*void evalInBsh(){
   bshInterp.eval(new StringReader(commandline),bshInterp.getNameSpace(),"input");
    }catch(Exception e){Object o;if(e instanceof InvocationTargetException){o=((InvocationTargetException)e).getTargetException();commanderr+=";"+o;}else{ commanderr+=";"+e;}}
    new Thread(new Runnable(){ public void run(){
     InputStreamReader tin; PrintStream tout;
     while(true){
      try{ tin=new InputStreamReader((BufferedInputStream)bshInterp.getNameSpace().get("_stdin",bshInterp));
      }catch(Exception e){tin=new InputStreamReader((InputStream)System.in);} //UtilEvalError mustbe caught
      try{   tout=new PrintStream((BufferedOutputStream)bshInterp.getNameSpace().get("_stdout",bshInterp)); //UtilEvalError mustbe caught
      }catch(Exception e){ tout=new PrintStream(new BufferedOutputStream((OutputStream)System.out)); }
     try{ new Interpreter((Reader)tin,tout,tout,false,bshInterp.getNameSpace(),bshInterp,"xserv").run();
     catch(Exception e){Object o;if(e instanceof InvocationTargetException){o=((InvocationTargetException)e).getTargetException();commanderr+=";"+o;}else{ commanderr+=";"+e;}}
     }
   }}).start();
     }
  */
      private void createLocalTermSession(){
        if ((cmd.toString()=="sh") && cmd.toString().equals(procCmd)){
          procCmd=cmd;
          ProcessBuilder execBuild = new ProcessBuilder();
          execBuild.redirectErrorStream(true);
          try {
           exec = execBuild.start();
           sin=exec.getInputStream();
           sout=exec.getOutputStream();
          }catch(Exception e){
           Log.e(TAG,"error executing: "+procCmd+" "+e.getMessage());
          }

       mIsRunning=true;
       Thread watcher = new Thread() {
       @Override
        public void run() {
         //Log.i(TAG, "polling " + mProcId);
         int result = execlib.waitFor(mProcId);
         mMsgHandler.sendEmptyMessage(result);
        }
       };
       watcher.setName("ptyPar:"+mSessFd);
       watcher.start();

       mReceiveBuffer = new byte[4 * 1024];
       mByteQueue = new ByteQueue(4 * 1024);

       mPollingThread = new Thread() {
        private byte[] mBuffer = new byte[4096];
        @Override
        public void run() {
          try {
           while(true) {
	    if (bSess==null)
             int read = mSessIn.read(mBuffer);
	    else
             int read = bSessIn.read(mBuffer); 
            if (read == -1) {
              return;
            }
            mByteQueue.write(mBuffer, 0, read);
            mMsgHandler.sendMessage( mMsgHandler.obtainMessage(NEW_INPUT));
           }
           } catch (IOException e) {
           } catch (InterruptedException e) {
           }
         }
         };
         mPollingThread.setName("poll");
         mPollingThread.start();
         //File localpath=new File(LaunchActivity.getDataDir(this));
	procCmd=cmd;
    }
    private View.OnKeyListener mKeyListener=new View.OnKeyListener(){
	public boolean onKey(View v, int keyCode, KeyEvent event){
	 return(backkeyIntercept(keyCode,event)||keyboardShortcuts(keyCode,event));
	}
	private boolean keyboardShortcuts(int keyCode, KeyEvent event){
	 if (event.getAction()!=KeyEvent.ACTION_DOWN){ return(false); }
	 //if (!shortcuts_enabled){return(false);}
	 boolean isCtrlPressed=(event.getMetaState()&KeycodeConstants.META_CTRL_ON)!=0;
	 boolean isShiftPressed=(event.getMetaState()&KeycodeConstants.META_SHIFT_ON)!=0;
	 if (keyCode==KeycodeConstants.KEYCODE_TAB&&isCtrlPressed) { return(true); 
         } else if (!isShiftPressed && isCtrlPressed) {
	  if (keyCode==KeycodeConstants.KEYCODE_N) { 
	   return(true);
	  } else if (keyCode==KeycodeConstants.KEYCODE_V){
	   //doPaste();
	   return(true);
	  } else if (keyCode==KeycodeConstants.KEYCODE_C){ return(false); }
	 } else { return(false); }
       }
     private boolean backkeyIntercept(int keyCode, KeyEvent event){
      if (keyCode==KeyEvent.KEYCODE_BACK)//&&mActionBarMode==Setting.ACTION_BAR_MODE_HIDES&&mActionBar.isShowing())
      { onBackPressed();
	Log.e(TAG,"onKeyUp:KEYCODE_BACK"); return(true);
      }else { return(false); }
	
     }
   };
   @Override 
   public boolean onKeyDown(int keyCode, KeyEvent event){
    //if (AndroidCompat.SDK<5&&keyCode==KeyEvent.KEYCODE_BACK){
    // return(true);
    //}else [
    return(super.onKeyDown(keyCode,event));
    //}
   }
   @Override
   public boolean onKeyUp(int keyCode, KeyEvent event){
    switch(keyCode){
     case KeyEvent.KEYCODE_BACK:
      onBackPressed(); 
      return(false);
     case KeyEvent.KEYCODE_MENU:
      return(super.onKeyUp(keyCode,event));
     default: 
	return(super.onKeyUp(keyCode,event));
    }


   }
   private class EmulatorViewGestureListener extends SimpleOnGestureListener {
    private EmulatorView mView;
    public EmulatorViewGestureListener(EmulatorView view) {
     this.mView=view;
    }
    @Override
    public boolean onSingleTapUp(MotionEvent e) { 
     //if (mView.isMouseTrackingActive()) return false; 
     String link = mView.getURLat(e.getX(),e.getY());
     ClipboardManager clip=(ClipboardManager)(getApplicationContext().getSystemService(Context.CLIPBOARD_SERVICE));
     clip.setText(link);
     //mView.toggleSelectingText();
//     if (link!=null)
//      execURL(link);
//     else { //doUIToggle((int)e.getX(),(int)e.getY(),view.getVisibleWidth(),view.getVisibleHeight());
     mView.requestFocus();
      InputMethodManager imm=(InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);
      imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
//     }
     return(true);
    }
   }
   @Override
   public void onUpdate() { 
    DisplayMetrics metrics = new DisplayMetrics();
    getWindowManager().getDefaultDisplay().getMetrics(metrics);
    mEmulatorView.setDensity(metrics);
    myIntent = getIntent();
    String sessionstate = myIntent.getStringExtra("state");
 /* Done once with a sticky flag stays set in android11&> */
    //getWindow().addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN|WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS|WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); 
    //getActionBar().hide();
   }
   private void execURL(String link) {
   } 
     
}
package com.termx;

import com.termx.AndroidCompat;
import com.termx.KeyCharacterMapCompat;

import java.io.IOException;
import java.util.Map;
import java.util.HashMap;

import android.util.Log;
import android.view.KeyCharacterMap;
import android.view.KeyEvent;
import static com.termx.KeycodeConstants.*;

/**
 * An ASCII key listener. Supports control characters and escape. Keeps track of
 * the current state of the alt, shift, fn, and control keys.
 *
 */
class TermKeyListener {
    private final static String TAG = "TermKeyListener";
    private static final boolean LOG_MISC = false;
    private static final boolean LOG_KEYS = false;
    private static final boolean LOG_COMBINING_ACCENT = false;

    /** Disabled for now because it interferes with ALT processing on phones with physical keyboards. */
    private final static boolean SUPPORT_8_BIT_META = false;

    private static final int KEYMOD_ALT   = 0x80000000;
    private static final int KEYMOD_CTRL  = 0x40000000;
    private static final int KEYMOD_SHIFT = 0x20000000;
    /** Means this maps raw scancode */
    private static final int KEYMOD_SCAN  = 0x10000000;

    private static Map<Integer, String> mKeyMap;

    private String[] mKeyCodes = new String[256];
    private String[] mAppKeyCodes = new String[256];

    private void initKeyCodes() {
        mKeyMap = new HashMap<Integer, String>();
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_DPAD_LEFT, "\033[1;2D");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_DPAD_LEFT, "\033[1;3D");
        mKeyMap.put(KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_LEFT, "\033[1;4D");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_DPAD_LEFT, "\033[1;5D");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_SHIFT | KEYCODE_DPAD_LEFT, "\033[1;6D");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYCODE_DPAD_LEFT, "\033[1;7D");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_LEFT, "\033[1;8D");

        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_DPAD_RIGHT, "\033[1;2C");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_DPAD_RIGHT, "\033[1;3C");
        mKeyMap.put(KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_RIGHT, "\033[1;4C");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_DPAD_RIGHT, "\033[1;5C");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_SHIFT | KEYCODE_DPAD_RIGHT, "\033[1;6C");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYCODE_DPAD_RIGHT, "\033[1;7C");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_RIGHT, "\033[1;8C");

        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_DPAD_UP, "\033[1;2A");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_DPAD_UP, "\033[1;3A");
        mKeyMap.put(KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_UP, "\033[1;4A");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_DPAD_UP, "\033[1;5A");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_SHIFT | KEYCODE_DPAD_UP, "\033[1;6A");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYCODE_DPAD_UP, "\033[1;7A");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_UP, "\033[1;8A");

        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_DPAD_DOWN, "\033[1;2B");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_DPAD_DOWN, "\033[1;3B");
        mKeyMap.put(KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_DOWN, "\033[1;4B");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_DPAD_DOWN, "\033[1;5B");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_SHIFT | KEYCODE_DPAD_DOWN, "\033[1;6B");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYCODE_DPAD_DOWN, "\033[1;7B");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_DOWN, "\033[1;8B");

        //^[[3~
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_FORWARD_DEL, "\033[3;2~");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_FORWARD_DEL, "\033[3;3~");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_FORWARD_DEL, "\033[3;5~");

        //^[[2~
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_INSERT, "\033[2;2~");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_INSERT, "\033[2;3~");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_INSERT, "\033[2;5~");

        mKeyMap.put(KEYMOD_CTRL | KEYCODE_MOVE_HOME, "\033[1;5H");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_MOVE_END, "\033[1;5F");

        mKeyMap.put(KEYMOD_ALT | KEYCODE_ENTER, "\033\r");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_ENTER, "\n");
        // Duh, so special...
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_SPACE, "\000");

        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F1, "\033[1;2P");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F2, "\033[1;2Q");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F3, "\033[1;2R");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F4, "\033[1;2S");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F5, "\033[15;2~");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F6, "\033[17;2~");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F7, "\033[18;2~");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F8, "\033[19;2~");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F9, "\033[20;2~");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F10, "\033[21;2~");

        mKeyCodes[KEYCODE_DPAD_CENTER] = "\015";
        mKeyCodes[KEYCODE_DPAD_UP] = "\033[A";
        mKeyCodes[KEYCODE_DPAD_DOWN] = "\033[B";
        mKeyCodes[KEYCODE_DPAD_RIGHT] = "\033[C";
        mKeyCodes[KEYCODE_DPAD_LEFT] = "\033[D";
        setFnKeys("vt100");
        mKeyCodes[KEYCODE_SYSRQ] = "\033[32~"; // Sys Request / Print
        // Is this Scroll lock? mKeyCodes[Cancel] = "\033[33~";
        mKeyCodes[KEYCODE_BREAK] = "\033[34~"; // Pause/Break

        mKeyCodes[KEYCODE_TAB] = "\011";
        mKeyCodes[KEYCODE_ENTER] = "\015";
        mKeyCodes[KEYCODE_ESCAPE] = "\033";

        mKeyCodes[KEYCODE_INSERT] = "\033[2~";
        mKeyCodes[KEYCODE_FORWARD_DEL] = "\033[3~";
        // Home/End keys are set by setFnKeys()
        mKeyCodes[KEYCODE_PAGE_UP] = "\033[5~";
        mKeyCodes[KEYCODE_PAGE_DOWN] = "\033[6~";
        mKeyCodes[KEYCODE_DEL]= "\177";
        mKeyCodes[KEYCODE_NUM_LOCK] = "\033OP";
        mKeyCodes[KEYCODE_NUMPAD_DIVIDE] = "/";
        mKeyCodes[KEYCODE_NUMPAD_MULTIPLY] = "*";
        mKeyCodes[KEYCODE_NUMPAD_SUBTRACT] = "-";
        mKeyCodes[KEYCODE_NUMPAD_ADD] = "+";
        mKeyCodes[KEYCODE_NUMPAD_ENTER] = "\015";
        mKeyCodes[KEYCODE_NUMPAD_EQUALS] = "=";
        mKeyCodes[KEYCODE_NUMPAD_COMMA] = ",";
/*
        mKeyCodes[KEYCODE_NUMPAD_DOT] = ".";
        mKeyCodes[KEYCODE_NUMPAD_0] = "0";
        mKeyCodes[KEYCODE_NUMPAD_1] = "1";
        mKeyCodes[KEYCODE_NUMPAD_2] = "2";
        mKeyCodes[KEYCODE_NUMPAD_3] = "3";
        mKeyCodes[KEYCODE_NUMPAD_4] = "4";
        mKeyCodes[KEYCODE_NUMPAD_5] = "5";
        mKeyCodes[KEYCODE_NUMPAD_6] = "6";
        mKeyCodes[KEYCODE_NUMPAD_7] = "7";
        mKeyCodes[KEYCODE_NUMPAD_8] = "8";
        mKeyCodes[KEYCODE_NUMPAD_9] = "9";
*/
        // Keypad is used for cursor/func keys
        mKeyCodes[KEYCODE_NUMPAD_DOT] = mKeyCodes[KEYCODE_FORWARD_DEL];
        mKeyCodes[KEYCODE_NUMPAD_0] = mKeyCodes[KEYCODE_INSERT];
        mKeyCodes[KEYCODE_NUMPAD_1] = mKeyCodes[KEYCODE_MOVE_END];
        mKeyCodes[KEYCODE_NUMPAD_2] = mKeyCodes[KEYCODE_DPAD_DOWN];
        mKeyCodes[KEYCODE_NUMPAD_3] = mKeyCodes[KEYCODE_PAGE_DOWN];
        mKeyCodes[KEYCODE_NUMPAD_4] = mKeyCodes[KEYCODE_DPAD_LEFT];
        mKeyCodes[KEYCODE_NUMPAD_5] = "5";
        mKeyCodes[KEYCODE_NUMPAD_6] = mKeyCodes[KEYCODE_DPAD_RIGHT];
        mKeyCodes[KEYCODE_NUMPAD_7] = mKeyCodes[KEYCODE_MOVE_HOME];
        mKeyCodes[KEYCODE_NUMPAD_8] = mKeyCodes[KEYCODE_DPAD_UP];
        mKeyCodes[KEYCODE_NUMPAD_9] = mKeyCodes[KEYCODE_PAGE_UP];


//        mAppKeyCodes[KEYCODE_DPAD_UP] = "\033OA";
//        mAppKeyCodes[KEYCODE_DPAD_DOWN] = "\033OB";
//        mAppKeyCodes[KEYCODE_DPAD_RIGHT] = "\033OC";
//        mAppKeyCodes[KEYCODE_DPAD_LEFT] = "\033OD";
        mAppKeyCodes[KEYCODE_NUMPAD_DIVIDE] = "\033Oo";
        mAppKeyCodes[KEYCODE_NUMPAD_MULTIPLY] = "\033Oj";
        mAppKeyCodes[KEYCODE_NUMPAD_SUBTRACT] = "\033Om";
        mAppKeyCodes[KEYCODE_NUMPAD_ADD] = "\033Ok";
        mAppKeyCodes[KEYCODE_NUMPAD_ENTER] = "\033OM";
        mAppKeyCodes[KEYCODE_NUMPAD_EQUALS] = "\033OX";
        mAppKeyCodes[KEYCODE_NUMPAD_DOT] = "\033On";
        mAppKeyCodes[KEYCODE_NUMPAD_COMMA] = "\033Ol";
        mAppKeyCodes[KEYCODE_NUMPAD_0] = "\033Op";
        mAppKeyCodes[KEYCODE_NUMPAD_1] = "\033Oq";
        mAppKeyCodes[KEYCODE_NUMPAD_2] = "\033Or";
        mAppKeyCodes[KEYCODE_NUMPAD_3] = "\033Os";
        mAppKeyCodes[KEYCODE_NUMPAD_4] = "\033Ot";
        mAppKeyCodes[KEYCODE_NUMPAD_5] = "\033Ou";
        mAppKeyCodes[KEYCODE_NUMPAD_6] = "\033Ov";
        mAppKeyCodes[KEYCODE_NUMPAD_7] = "\033Ow";
        mAppKeyCodes[KEYCODE_NUMPAD_8] = "\033Ox";
        mAppKeyCodes[KEYCODE_NUMPAD_9] = "\033Oy";
    }

    public void setCursorKeysApplicationMode(boolean val) {
        if (LOG_MISC) {
            Log.d(TAG, "CursorKeysApplicationMode=" + val);
        }
        if (val) {
            mKeyCodes[KEYCODE_NUMPAD_8] = mKeyCodes[KEYCODE_DPAD_UP] = "\033OA";
            mKeyCodes[KEYCODE_NUMPAD_2] = mKeyCodes[KEYCODE_DPAD_DOWN] = "\033OB";
            mKeyCodes[KEYCODE_NUMPAD_6] = mKeyCodes[KEYCODE_DPAD_RIGHT] = "\033OC";
            mKeyCodes[KEYCODE_NUMPAD_4] = mKeyCodes[KEYCODE_DPAD_LEFT] = "\033OD";
        } else {
            mKeyCodes[KEYCODE_NUMPAD_8] = mKeyCodes[KEYCODE_DPAD_UP] = "\033[A";
            mKeyCodes[KEYCODE_NUMPAD_2] = mKeyCodes[KEYCODE_DPAD_DOWN] = "\033[B";
            mKeyCodes[KEYCODE_NUMPAD_6] = mKeyCodes[KEYCODE_DPAD_RIGHT] = "\033[C";
            mKeyCodes[KEYCODE_NUMPAD_4] = mKeyCodes[KEYCODE_DPAD_LEFT] = "\033[D";
        }
    }

    /**
     * The state engine for a modifier key. Can be pressed, released, locked,
     * and so on.
     *
     */
    private class ModifierKey {

        private int mState;

        private static final int UNPRESSED = 0;

        private static final int PRESSED = 1;

        private static final int RELEASED = 2;

        private static final int USED = 3;

        private static final int LOCKED = 4;

        /**
         * Construct a modifier key. UNPRESSED by default.
         *
         */
        public ModifierKey() {
            mState = UNPRESSED;
        }

        public void onPress() {
            switch (mState) {
            case PRESSED:
                // This is a repeat before use
                break;
            case RELEASED:
                mState = LOCKED;
                break;
            case USED:
                // This is a repeat after use
                break;
            case LOCKED:
                mState = UNPRESSED;
                break;
            default:
                mState = PRESSED;
                break;
            }
        }

        public void onRelease() {
            switch (mState) {
            case USED:
                mState = UNPRESSED;
                break;
            case PRESSED:
                mState = RELEASED;
                break;
            default:
                // Leave state alone
                break;
            }
        }

        public void adjustAfterKeypress() {
            switch (mState) {
            case PRESSED:
                mState = USED;
                break;
            case RELEASED:
                mState = UNPRESSED;
                break;
            default:
                // Leave state alone
                break;
            }
        }

        public boolean isActive() {
            return mState != UNPRESSED;
        }

        public int getUIMode() {
            switch (mState) {
            default:
            case UNPRESSED:
                return TextRenderer.MODE_OFF;
            case PRESSED:
            case RELEASED:
            case USED:
                return TextRenderer.MODE_ON;
            case LOCKED:
                return TextRenderer.MODE_LOCKED;
            }
        }
    }

    private ModifierKey mAltKey = new ModifierKey();

    private ModifierKey mCapKey = new ModifierKey();

    private ModifierKey mControlKey = new ModifierKey();

    private ModifierKey mFnKey = new ModifierKey();

    private int mCursorMode;

    private boolean mHardwareControlKey;

    private TermSession mTermSession;

    private int mBackKeyCode;
    private boolean mAltSendsEsc;

    private int mCombiningAccent;

    // Map keycodes out of (above) the Unicode code point space.
    static public final int KEYCODE_OFFSET = 0xA00000;

    /**
     * Construct a term key listener.
     *
     */
    public TermKeyListener(TermSession termSession) {
        mTermSession = termSession;
        initKeyCodes();
        updateCursorMode();
    }

    public void setBackKeyCharacter(int code) {
        mBackKeyCode = code;
    }

    public void setAltSendsEsc(boolean flag) {
        mAltSendsEsc = flag;
    }

    public void handleHardwareControlKey(boolean down) {
        mHardwareControlKey = down;
    }

    public void onPause() {
        // Ensure we don't have any left-over modifier state when switching
        // views.
        mHardwareControlKey = false;
    }

    public void onResume() {
        // Nothing special.
    }

    public void handleControlKey(boolean down) {
        if (down) {
            mControlKey.onPress();
        } else {
            mControlKey.onRelease();
        }
        updateCursorMode();
    }

    public void handleFnKey(boolean down) {
        if (down) {
            mFnKey.onPress();
        } else {
            mFnKey.onRelease();
        }
        updateCursorMode();
    }

    public void setTermType(String termType) {
        setFnKeys(termType);
    }

    private void setFnKeys(String termType) {
        // These key assignments taken from the debian squeeze terminfo database.
        if (termType.equals("xterm")) {
            mKeyCodes[KEYCODE_NUMPAD_7] = mKeyCodes[KEYCODE_MOVE_HOME] = "\033OH";
            mKeyCodes[KEYCODE_NUMPAD_1] = mKeyCodes[KEYCODE_MOVE_END] = "\033OF";
        } else {
            mKeyCodes[KEYCODE_NUMPAD_7] = mKeyCodes[KEYCODE_MOVE_HOME] = "\033[1~";
            mKeyCodes[KEYCODE_NUMPAD_1] = mKeyCodes[KEYCODE_MOVE_END] = "\033[4~";
        }
        if (termType.equals("vt100")) {
            mKeyCodes[KEYCODE_F1] = "\033OP"; // VT100 PF1
            mKeyCodes[KEYCODE_F2] = "\033OQ"; // VT100 PF2
            mKeyCodes[KEYCODE_F3] = "\033OR"; // VT100 PF3
            mKeyCodes[KEYCODE_F4] = "\033OS"; // VT100 PF4
            // the following keys are in the database, but aren't on a real vt100.
            mKeyCodes[KEYCODE_F5] = "\033Ot";
            mKeyCodes[KEYCODE_F6] = "\033Ou";
            mKeyCodes[KEYCODE_F7] = "\033Ov";
            mKeyCodes[KEYCODE_F8] = "\033Ol";
            mKeyCodes[KEYCODE_F9] = "\033Ow";
            mKeyCodes[KEYCODE_F10] = "\033Ox";
            // The following keys are not in database.
            mKeyCodes[KEYCODE_F11] = "\033[23~";
            mKeyCodes[KEYCODE_F12] = "\033[24~";
        } else if (termType.startsWith("linux")) {
            mKeyCodes[KEYCODE_F1] = "\033[[A";
            mKeyCodes[KEYCODE_F2] = "\033[[B";
            mKeyCodes[KEYCODE_F3] = "\033[[C";
            mKeyCodes[KEYCODE_F4] = "\033[[D";
            mKeyCodes[KEYCODE_F5] = "\033[[E";
            mKeyCodes[KEYCODE_F6] = "\033[17~";
            mKeyCodes[KEYCODE_F7] = "\033[18~";
            mKeyCodes[KEYCODE_F8] = "\033[19~";
            mKeyCodes[KEYCODE_F9] = "\033[20~";
            mKeyCodes[KEYCODE_F10] = "\033[21~";
            mKeyCodes[KEYCODE_F11] = "\033[23~";
            mKeyCodes[KEYCODE_F12] = "\033[24~";
        } else {
            // default
            // screen, screen-256colors, xterm, anything new
            mKeyCodes[KEYCODE_F1] = "\033OP"; // VT100 PF1
            mKeyCodes[KEYCODE_F2] = "\033OQ"; // VT100 PF2
            mKeyCodes[KEYCODE_F3] = "\033OR"; // VT100 PF3
            mKeyCodes[KEYCODE_F4] = "\033OS"; // VT100 PF4
            mKeyCodes[KEYCODE_F5] = "\033[15~";
            mKeyCodes[KEYCODE_F6] = "\033[17~";
            mKeyCodes[KEYCODE_F7] = "\033[18~";
            mKeyCodes[KEYCODE_F8] = "\033[19~";
            mKeyCodes[KEYCODE_F9] = "\033[20~";
            mKeyCodes[KEYCODE_F10] = "\033[21~";
            mKeyCodes[KEYCODE_F11] = "\033[23~";
            mKeyCodes[KEYCODE_F12] = "\033[24~";
        }
    }

    public int mapControlChar(int ch) {
        return mapControlChar(mHardwareControlKey || mControlKey.isActive(), mFnKey.isActive(), ch);
    }

    public int mapControlChar(boolean control, boolean fn, int ch) {
        int result = ch;
        if (control) {
            // Search is the control key.
            if (result >= 'a' && result <= 'z') {
                result = (char) (result - 'a' + '\001');
            } else if (result >= 'A' && result <= 'Z') {
                result = (char) (result - 'A' + '\001');
            } else if (result == ' ' || result == '2') {
                result = 0;
            } else if (result == '[' || result == '3') {
                result = 27; // ^[ (Esc)
            } else if (result == '\\' || result == '4') {
                result = 28;
            } else if (result == ']' || result == '5') {
                result = 29;
            } else if (result == '^' || result == '6') {
                result = 30; // control-^
            } else if (result == '_' || result == '7') {
                result = 31;
            } else if (result == '8') {
                result = 127; // DEL
            } else if (result == '9') {
                result = KEYCODE_OFFSET + KEYCODE_F11;
            } else if (result == '0') {
                result = KEYCODE_OFFSET + KEYCODE_F12;
            }
        } else if (fn) {
            if (result == 'w' || result == 'W') {
                result = KEYCODE_OFFSET + KeyEvent.KEYCODE_DPAD_UP;
            } else if (result == 'a' || result == 'A') {
                result = KEYCODE_OFFSET + KeyEvent.KEYCODE_DPAD_LEFT;
            } else if (result == 's' || result == 'S') {
                result = KEYCODE_OFFSET + KeyEvent.KEYCODE_DPAD_DOWN;
            } else if (result == 'd' || result == 'D') {
                result = KEYCODE_OFFSET + KeyEvent.KEYCODE_DPAD_RIGHT;
            } else if (result == 'p' || result == 'P') {
                result = KEYCODE_OFFSET + KEYCODE_PAGE_UP;
            } else if (result == 'n' || result == 'N') {
                result = KEYCODE_OFFSET + KEYCODE_PAGE_DOWN;
            } else if (result == 't' || result == 'T') {
                result = KEYCODE_OFFSET + KeyEvent.KEYCODE_TAB;
            } else if (result == 'l' || result == 'L') {
                result = '|';
            } else if (result == 'u' || result == 'U') {
                result = '_';
            } else if (result == 'e' || result == 'E') {
                result = 27; // ^[ (Esc)
            } else if (result == '.') {
                result = 28; // ^\
            } else if (result > '0' && result <= '9') {
                // F1-F9
                result = (char)(result + KEYCODE_OFFSET + KEYCODE_F1 - 1);
            } else if (result == '0') {
                result = KEYCODE_OFFSET + KEYCODE_F10;
            } else if (result == 'i' || result == 'I') {
                result = KEYCODE_OFFSET + KEYCODE_INSERT;
            } else if (result == 'x' || result == 'X') {
                result = KEYCODE_OFFSET + KEYCODE_FORWARD_DEL;
            } else if (result == 'h' || result == 'H') {
                result = KEYCODE_OFFSET + KEYCODE_MOVE_HOME;
            } else if (result == 'f' || result == 'F') {
                result = KEYCODE_OFFSET + KEYCODE_MOVE_END;
            }
        }

        if (result > -1) {
            mAltKey.adjustAfterKeypress();
            mCapKey.adjustAfterKeypress();
            mControlKey.adjustAfterKeypress();
            mFnKey.adjustAfterKeypress();
            updateCursorMode();
        }

        return result;
    }

    /**
     * Handle a keyDown event.
     *
     * @param keyCode the keycode of the keyDown event
     *
     */
    public void keyDown(int keyCode, KeyEvent event, boolean appMode,
            boolean allowToggle) throws IOException {
        if (LOG_KEYS) {
            Log.i(TAG, "keyDown(" + keyCode + "," + event + "," + appMode + "," + allowToggle + ")");
        }
        if (handleKeyCode(keyCode, event, appMode)) {
            return;
        }
        int result = -1;
        boolean chordedCtrl = false;
        boolean setHighBit = false;
        switch (keyCode) {
        case KeyEvent.KEYCODE_ALT_RIGHT:
        case KeyEvent.KEYCODE_ALT_LEFT:
            if (allowToggle) {
                mAltKey.onPress();
                updateCursorMode();
            }
            break;

        case KeyEvent.KEYCODE_SHIFT_LEFT:
        case KeyEvent.KEYCODE_SHIFT_RIGHT:
            if (allowToggle) {
                mCapKey.onPress();
                updateCursorMode();
            }
            break;

        case KEYCODE_CTRL_LEFT:
        case KEYCODE_CTRL_RIGHT:
            // Ignore the control key.
            return;

        case KEYCODE_CAPS_LOCK:
            // Ignore the capslock key.
            return;

        case KEYCODE_FUNCTION:
            // Ignore the function key.
            return;

        case KeyEvent.KEYCODE_BACK:
            result = mBackKeyCode;
            break;

        default: {
            int metaState = event.getMetaState();
            chordedCtrl = ((META_CTRL_ON & metaState) != 0);
            boolean effectiveCaps = allowToggle &&
                    (mCapKey.isActive());
            boolean effectiveAlt = allowToggle && mAltKey.isActive();
            int effectiveMetaState = metaState & (~META_CTRL_MASK);
            if (effectiveCaps) {
                effectiveMetaState |= KeyEvent.META_SHIFT_ON;
            }
            if (!allowToggle && (effectiveMetaState & META_ALT_ON) != 0) {
                effectiveAlt = true;
            }
            if (effectiveAlt) {
                if (mAltSendsEsc) {
                    mTermSession.write(new byte[]{0x1b},0,1);
                    effectiveMetaState &= ~KeyEvent.META_ALT_MASK;
                } else if (SUPPORT_8_BIT_META) {
                    setHighBit = true;
                    effectiveMetaState &= ~KeyEvent.META_ALT_MASK;
                } else {
                    // Legacy behavior: Pass Alt through to allow composing characters.
                    effectiveMetaState |= KeyEvent.META_ALT_ON;
                }
            }

            // Note: The Hacker keyboard IME key labeled Alt actually sends Meta.


            if ((metaState & KeyEvent.META_META_ON) != 0) {
                if (mAltSendsEsc) {
                    mTermSession.write(new byte[]{0x1b},0,1);
                    effectiveMetaState &= ~KeyEvent.META_META_MASK;
                } else {
                    if (SUPPORT_8_BIT_META) {
                        setHighBit = true;
                        effectiveMetaState &= ~KeyEvent.META_META_MASK;
                    }
                }
            }
            result = event.getUnicodeChar(effectiveMetaState);

            if ((result & KeyCharacterMap.COMBINING_ACCENT) != 0) {
                if (LOG_COMBINING_ACCENT) {
                    Log.i(TAG, "Got combining accent " + result);
                }
                mCombiningAccent = result & KeyCharacterMap.COMBINING_ACCENT_MASK;
                return;
            }
            if (mCombiningAccent != 0) {
                int unaccentedChar = result;
                result = KeyCharacterMap.getDeadChar(mCombiningAccent, unaccentedChar);
                if (LOG_COMBINING_ACCENT) {
                    Log.i(TAG, "getDeadChar(" + mCombiningAccent + ", " + unaccentedChar + ") -> " + result);
                }
                mCombiningAccent = 0;
            }

            break;
            }
        }

        boolean effectiveControl = chordedCtrl || mHardwareControlKey || (allowToggle && mControlKey.isActive());
        boolean effectiveFn = allowToggle && mFnKey.isActive();

        result = mapControlChar(effectiveControl, effectiveFn, result);

        if (result >= KEYCODE_OFFSET) {
            handleKeyCode(result - KEYCODE_OFFSET, null, appMode);
        } else if (result >= 0) {
            if (setHighBit) {
                result |= 0x80;
            }
            mTermSession.write(result);
        }
    }

    public int getCombiningAccent() {
        return mCombiningAccent;
    }

    public int getCursorMode() {
        return mCursorMode;
    }

    private void updateCursorMode() {
        mCursorMode = getCursorModeHelper(mCapKey, TextRenderer.MODE_SHIFT_SHIFT)
                | getCursorModeHelper(mAltKey, TextRenderer.MODE_ALT_SHIFT)
                | getCursorModeHelper(mControlKey, TextRenderer.MODE_CTRL_SHIFT)
                | getCursorModeHelper(mFnKey, TextRenderer.MODE_FN_SHIFT);
    }

    private static int getCursorModeHelper(ModifierKey key, int shift) {
        return key.getUIMode() << shift;
    }

    static boolean isEventFromToggleDevice(KeyEvent event) {
        if (AndroidCompat.SDK < 11) {
            return true;
        }
        KeyCharacterMapCompat kcm = KeyCharacterMapCompat.wrap(
                KeyCharacterMap.load(event.getDeviceId()));
        return kcm.getModifierBehaviour() ==
                KeyCharacterMapCompat.MODIFIER_BEHAVIOR_CHORDED_OR_TOGGLED;
    }

    public boolean handleKeyCode(int keyCode, KeyEvent event, boolean appMode) throws IOException {
        String code = null;
        if (event != null) {
            int keyMod = 0;
            // META_CTRL_ON was added only in API 11, so don't use it,
            // use our own tracking of Ctrl key instead.
            // (event.getMetaState() & META_CTRL_ON) != 0
            if (mHardwareControlKey || mControlKey.isActive()) {
                keyMod |= KEYMOD_CTRL;
            }
            if ((event.getMetaState() & META_ALT_ON) != 0) {
                keyMod |= KEYMOD_ALT;
            }
            if ((event.getMetaState() & META_SHIFT_ON) != 0) {
                keyMod |= KEYMOD_SHIFT;
            }
            // First try to map scancode
            code = mKeyMap.get(event.getScanCode() | KEYMOD_SCAN | keyMod);
            if (code == null) {
                code = mKeyMap.get(keyCode | keyMod);
            }
        }

        if (code == null && keyCode >= 0 && keyCode < mKeyCodes.length) {
            if (appMode) {
                code = mAppKeyCodes[keyCode];
            }
            if (code == null) {
                code = mKeyCodes[keyCode];
            }
        }

        if (code != null) {
           /* if (EmulatorDebug.LOG_CHARACTERS_FLAG) {
                byte[] bytes = code.getBytes();
                Log.d(TAG, "Out: '" + EmulatorDebug.bytesToString(bytes, 0, bytes.length) + "'");
            }
	*/
            mTermSession.write(code);
            return true;
        }
        return false;
    }

    /**
     * Handle a keyUp event.
     *
     * @param keyCode the keyCode of the keyUp event
     */
    public void keyUp(int keyCode, KeyEvent event) {
        boolean allowToggle = isEventFromToggleDevice(event);
        switch (keyCode) {
        case KeyEvent.KEYCODE_ALT_LEFT:
        case KeyEvent.KEYCODE_ALT_RIGHT:
            if (allowToggle) {
                mAltKey.onRelease();
                updateCursorMode();
            }
            break;
        case KeyEvent.KEYCODE_SHIFT_LEFT:
        case KeyEvent.KEYCODE_SHIFT_RIGHT:
            if (allowToggle) {
                mCapKey.onRelease();
                updateCursorMode();
            }
            break;

        case KEYCODE_CTRL_LEFT:
        case KEYCODE_CTRL_RIGHT:
            // ignore control keys.
            break;

        default:
            // Ignore other keyUps
            break;
        }
    }

    public boolean getAltSendsEsc() {
        return mAltSendsEsc;
    }

    public boolean isAltActive() {
        return mAltKey.isActive();
    }

    public boolean isCtrlActive() {
        return mControlKey.isActive();
    }
}

package com.termx;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CodingErrorAction;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;

/**
 * A terminal session, consisting of a VT100 terminal emulator and its
 * input and output streams.
 * <p>
 * You need to supply an {@link InputStream} and {@link OutputStream} to
 * provide input and output to the terminal.  For a locally running
 * program, these would typically point to a tty; for a telnet program
 * they might point to a network socket.  Reader and writer threads will be
 * spawned to do I/O to these streams.  All other operations, including
 * processing of input and output in {@link #processInput processInput} and
 * {@link #write(byte[], int, int) write}, will be performed on the main thread.
 * <p>
 * Call {@link #setTermIn} and {@link #setTermOut} to connect the input and
 * output streams to the emulator.  When all of your initialization is
 * complete, your initial screen size is known, and you're ready to
 * start VT100 emulation, call {@link #initializeEmulator} or {@link
 * #updateSize} with the number of rows and columns the terminal should
 * initially have.  (If you attach the session to an {@link EmulatorView},
 * the view will take care of setting the screen size and initializing the
 * emulator for you.)
 * <p>
 * When you're done with the session, you should call {@link #finish} on it.
 * This frees emulator data from memory, stops the reader and writer threads,
 * and closes the attached I/O streams.
 */
public class TermSession {
    public void setKeyListener(TermKeyListener l) {
        mKeyListener = l;
    }
    private TermKeyListener mKeyListener;

    private ColorScheme mColorScheme = BaseTextRenderer.defaultColorScheme;
    private UpdateCallback mNotify;

    private OutputStream mTermOut;
    private InputStream mTermIn;

    private String mTitle;

    private TranscriptScreen mTranscriptScreen;
    private termemu mEmulator;

    private boolean mDefaultUTF8Mode;

    private Thread mReaderThread;
    private ByteQueue mByteQueue;
    private byte[] mReceiveBuffer;

    private Thread mWriterThread;
    private ByteQueue mWriteQueue;
    private Handler mWriterHandler;

    private CharBuffer mWriteCharBuffer;
    private ByteBuffer mWriteByteBuffer;
    private CharsetEncoder mUTF8Encoder;

    // Number of rows in the transcript
    private static final int TRANSCRIPT_ROWS = 10000;

    private static final int NEW_INPUT = 1;
    private static final int NEW_OUTPUT = 2;
    private static final int FINISH = 3;

    /**
     * Callback to be invoked when a {@link TermSession} finishes.
     *
     * @see TermSession#setUpdateCallback
     */
    public interface FinishCallback {
        /**
         * Callback function to be invoked when a {@link TermSession} finishes.
         *
         * @param session The <code>TermSession</code> which has finished.
         */
        void onSessionFinish(TermSession session);
    }
    private FinishCallback mFinishCallback;

    private boolean mIsRunning = false;
    private Handler mMsgHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            if (!mIsRunning) {
                return;
            }
            if (msg.what == NEW_INPUT) {
                readFromProcess();
            }
        }
    };

    private UpdateCallback mTitleChangedListener;

    public TermSession() {
        mWriteCharBuffer = CharBuffer.allocate(2);
        mWriteByteBuffer = ByteBuffer.allocate(4);
        mUTF8Encoder = Charset.forName("UTF-8").newEncoder();
        mUTF8Encoder.onMalformedInput(CodingErrorAction.REPLACE);
        mUTF8Encoder.onUnmappableCharacter(CodingErrorAction.REPLACE);

        mReceiveBuffer = new byte[4 * 1024];
        mByteQueue = new ByteQueue(4 * 1024);
        mReaderThread = new Thread() {
            private byte[] mBuffer = new byte[4096];

            @Override
            public void run() {
                try {
                    while(true) {
                        int read = mTermIn.read(mBuffer);
                        if (read == -1) {
                            // EOF -- process exited
                            return;
                        }
                        int offset = 0;
                        while (read > 0 || offset<read) {
                            //int written = 
			mByteQueue.write(mBuffer,
                                    offset, read);
                            offset += read;//written;
                            read -= 1;//written;
                            mMsgHandler.sendMessage(
                                    mMsgHandler.obtainMessage(NEW_INPUT));
                        }
                    }
                } catch (IOException e) {
                } catch (InterruptedException e) {
                }
            }
        };
        mReaderThread.setName("TermSession input reader");

        mWriteQueue = new ByteQueue(4096);
        mWriterThread = new Thread() {
            private byte[] mBuffer = new byte[4096];

            @Override
            public void run() {
                Looper.prepare();

                mWriterHandler = new Handler() {
                    @Override
                    public void handleMessage(Message msg) {
                        if (msg.what == NEW_OUTPUT) {
                            writeToOutput();
                        } else if (msg.what == FINISH) {
                            Looper.myLooper().quit();
                        }
                    }
                };

                // Drain anything in the queue from before we started
                writeToOutput();

                Looper.loop();
            }

            private void writeToOutput() {
                ByteQueue writeQueue = mWriteQueue;
                byte[] buffer = mBuffer;
                OutputStream termOut = mTermOut;

                int bytesAvailable = writeQueue.getBytesAvailable();
                int bytesToWrite = Math.min(bytesAvailable, buffer.length);

                if (bytesToWrite == 0) {
                    return;
                }

                try {
                    writeQueue.read(buffer, 0, bytesToWrite);
                    termOut.write(buffer, 0, bytesToWrite);
                    termOut.flush();
                } catch (IOException e) {
                    // Ignore exception
                    // We don't really care if the receiver isn't listening.
                    // We just make a best effort to answer the query.
                } catch (InterruptedException e) {
                }
            }
        };
        mWriterThread.setName("TermSession output writer");
    }

    /**
     * Set the terminal emulator's window size and start terminal emulation.
     *
     * @param columns The number of columns in the terminal window.
     * @param rows The number of rows in the terminal window.
     */
    public void initializeEmulator(int columns, int rows) {
        mTranscriptScreen = new TranscriptScreen(columns, TRANSCRIPT_ROWS, rows, mColorScheme);
        mEmulator = new termemu(mTranscriptScreen, columns, rows, (FileOutputStream)mTermOut);

        mIsRunning = true;
        mReaderThread.start();
        mWriterThread.start();
    }

    /**
     * Write data to the terminal output.  The written data will be consumed by
     * the emulation client as input.
     * <p>
     * <code>write</code> itself runs on the main thread.  The default
     * implementation writes the data into a circular buffer and signals the
     * writer thread to copy it from there to the {@link OutputStream}.
     * <p>
     * Subclasses may override this method to modify the output before writing
     * it to the stream, but implementations in derived classes should call
     * through to this method to do the actual writing.
     *
     * @param data An array of bytes to write to the terminal.
     * @param offset The offset into the array at which the data starts.
     * @param count The number of bytes to be written.
     */
    public void write(byte[] data, int offset, int count) {
        try {
            while (count > 0||offset<count) {
                //int written = 
		mWriteQueue.write(data, offset, count);
                offset += count;//written;
                count -= 1;//written;
                notifyNewOutput();
            }
        } catch (InterruptedException e) {
        }
    }

    /**
     * Write the UTF-8 representation of a String to the terminal output.  The
     * written data will be consumed by the emulation client as input.
     * <p>
     * This implementation encodes the String and then calls
     * {@link #write(byte[], int, int)} to do the actual writing.  It should
     * therefore usually be unnecessary to override this method; override
     * {@link #write(byte[], int, int)} instead.
     *
     * @param data The String to write to the terminal.
     */
    public void write(String data) {
        try {
            byte[] bytes = data.getBytes("UTF-8");
            write(bytes, 0, bytes.length);
        } catch (UnsupportedEncodingException e) {
        }
    }

    /**
     * Write the UTF-8 representation of a single Unicode code point to the
     * terminal output.  The written data will be consumed by the emulation
     * client as input.
     * <p>
     * This implementation encodes the code point and then calls
     * {@link #write(byte[], int, int)} to do the actual writing.  It should
     * therefore usually be unnecessary to override this method; override
     * {@link #write(byte[], int, int)} instead.
     *
     * @param codePoint The Unicode code point to write to the terminal.
     */
    public void write(int codePoint) {
        CharBuffer charBuf = mWriteCharBuffer;
        ByteBuffer byteBuf = mWriteByteBuffer;
        CharsetEncoder encoder = mUTF8Encoder;

        charBuf.clear();
        byteBuf.clear();
        Character.toChars(codePoint, charBuf.array(), 0);
        encoder.reset();
        encoder.encode(charBuf, byteBuf, true);
        encoder.flush(byteBuf);
        write(byteBuf.array(), 0, byteBuf.position()-1);
    }

    /* Notify the writer thread that there's new output waiting */
    private void notifyNewOutput() {
        Handler writerHandler = mWriterHandler;
        if (writerHandler == null) {
           /* Writer thread isn't started -- will pick up data once it does */
           return;
        }
        writerHandler.sendEmptyMessage(NEW_OUTPUT);
    }

    /**
     * Get the {@link OutputStream} associated with this session.
     *
     * @return This session's {@link OutputStream}.
     */
    public OutputStream getTermOut() {
        return mTermOut;
    }

    /**
     * Set the {@link OutputStream} associated with this session.
     *
     * @param termOut This session's {@link OutputStream}.
     */
    public void setTermOut(OutputStream termOut) {
        mTermOut = termOut;
    }

    /**
     * Get the {@link InputStream} associated with this session.
     *
     * @return This session's {@link InputStream}.
     */
    public InputStream getTermIn() {
        return mTermIn;
    }

    /**
     * Set the {@link InputStream} associated with this session.
     *
     * @param termIn This session's {@link InputStream}.
     */
    public void setTermIn(InputStream termIn) {
        mTermIn = termIn;
    }

    /**
     * @return Whether the terminal emulation is currently running.
     */
    public boolean isRunning() {
        return mIsRunning;
    }

    TranscriptScreen getTranscriptScreen() {
        return mTranscriptScreen;
    }

    termemu getEmulator() {
        return mEmulator;
    }

    /**
     * Set an {@link UpdateCallback} to be invoked when the terminal emulator's
     * screen is changed.
     *
     * @param notify The {@link UpdateCallback} to be invoked on changes.
     */
    public void setUpdateCallback(UpdateCallback notify) {
        mNotify = notify;
    }

    /**
     * Notify the {@link UpdateCallback} registered by {@link
     * #setUpdateCallback setUpdateCallback} that the screen has changed.
     */
    protected void notifyUpdate() {
        if (mNotify != null) {
            mNotify.onUpdate();
        }
    }

    /**
     * Get the terminal session's title (may be null).
     */
    public String getTitle() {
        return mTitle;
    }

    /**
     * Change the terminal session's title.
     */
    public void setTitle(String title) {
        mTitle = title;
        notifyTitleChanged();
    }

    /**
     * Set an {@link UpdateCallback} to be invoked when the terminal emulator's
     * title is changed.
     *
     * @param listener The {@link UpdateCallback} to be invoked on changes.
     */
    public void setTitleChangedListener(UpdateCallback listener) {
        mTitleChangedListener = listener;
    }

    /**
     * Notify the UpdateCallback registered for title changes, if any, that the
     * terminal session's title has changed.
     *
     * @param title The terminal's new title.
     */
    protected void notifyTitleChanged() {
        UpdateCallback listener = mTitleChangedListener;
        if (listener != null) {
            listener.onUpdate();
        }
    }

    /**
     * Change the terminal's window size.  Will call {@link #initializeEmulator}
     * if the emulator is not yet running.
     * <p>
     * You should override this method if your application needs to be notified
     * when the screen size changes (for example, if you need to issue
     * <code>TIOCSWINSZ</code> to a tty to adjust the window size).  <em>If you
     * do override this method, you must call through to the superclass
     * implementation.</em>
     *
     * @param columns The number of columns in the terminal window.
     * @param rows The number of rows in the terminal window.
     */
    public void updateSize(int columns, int rows) {
        if (mEmulator == null) {
            initializeEmulator(columns, rows);
        } else {
            mEmulator.updateSize(columns, rows);
        }
    }

    /**
     * Retrieve the terminal's screen and scrollback buffer.
     *
     * @return A {@link String} containing the contents of the screen and
     *         scrollback buffer.
     */
    public String getTranscriptText() {
        return mTranscriptScreen.getTranscriptText();
    }

    /**
     * Look for new input from the ptty, send it to the terminal emulator.
     */
    private void readFromProcess() {
        int bytesAvailable = mByteQueue.getBytesAvailable();
        int bytesToRead = Math.min(bytesAvailable, mReceiveBuffer.length);
        int bytesRead = 0;
        try {
            bytesRead = mByteQueue.read(mReceiveBuffer, 0, bytesToRead);
        } catch (InterruptedException e) {
            return;
        }

        // Give subclasses a chance to process the read data
        processInput(mReceiveBuffer, 0, bytesRead);
        notifyUpdate();
    }

    /**
     * Process input and send it to the terminal emulator.  This method is
     * invoked on the main thread whenever new data is read from the
     * InputStream.
     * <p>
     * The default implementation sends the data straight to the terminal
     * emulator without modifying it in any way.  Subclasses can override it to
     * modify the data before giving it to the terminal.
     *
     * @param data A byte array containing the data read.
     * @param offset The offset into the buffer where the read data begins.
     * @param count The number of bytes read.
     */
    protected void processInput(byte[] data, int offset, int count) {
        mEmulator.append(data, offset, count);
    }

    /**
     * Write something directly to the terminal emulator input, bypassing the
     * emulation client, the session's {@link InputStream}, and any processing
     * being done by {@link #processInput processInput}.
     *
     * @param data The data to be written to the terminal.
     * @param offset The starting offset into the buffer of the data.
     * @param count The length of the data to be written.
     */
    protected final void appendToEmulator(byte[] data, int offset, int count) {
        mEmulator.append(data, offset, count);
    }

    /**
     * Set the terminal emulator's color scheme (default colors).
     *
     * @param scheme The {@link ColorScheme} to be used (use null for the
     *               default scheme).
     */

    /**
     * Set whether the terminal emulator should be in UTF-8 mode by default.
     * <p>
     * In UTF-8 mode, the terminal will handle UTF-8 sequences, allowing the
     * display of text in most of the world's languages, but applications must
     * encode C1 control characters and graphics drawing characters as the
     * corresponding UTF-8 sequences.
     *
     * @param utf8ByDefault Whether the terminal emulator should be in UTF-8
     *                      mode by default.
     */

    /**
     * Get whether the terminal emulator is currently in UTF-8 mode.
     *
     * @return Whether the emulator is currently in UTF-8 mode.
     */

    /**
     * Set an {@link UpdateCallback} to be invoked when the terminal emulator
     * goes into or out of UTF-8 mode.
     *
     * @param utf8ModeNotify The {@link UpdateCallback} to be invoked.
     */

    /**
     * Reset the terminal emulator's state.
     */
    public void reset() {
        mEmulator.reset();
        notifyUpdate();
    }

    /**
     * Set a {@link FinishCallback} to be invoked once this terminal session is
     * finished.
     *
     * @param callback The {@link FinishCallback} to be invoked on finish.
     */
    public void setFinishCallback(FinishCallback callback) {
        mFinishCallback = callback;
    }

    /**
     * Finish this terminal session.  Frees resources used by the terminal
     * emulator and closes the attached <code>InputStream</code> and
     * <code>OutputStream</code>.
     */
    public void finish() {
        mIsRunning = false;
        //mEmulator.finish();
        if (mTranscriptScreen != null) {
            mTranscriptScreen.finish();
        }

        // Stop the reader and writer threads, and close the I/O streams
        if (mWriterHandler != null) {
            mWriterHandler.sendEmptyMessage(FINISH);
        }
        try {
            mTermIn.close();
            mTermOut.close();
        } catch (IOException e) {
            // We don't care if this fails
        } catch (NullPointerException e) {
        }

        if (mFinishCallback != null) {
            mFinishCallback.onSessionFinish(this);
        }
    }
}

package com.termx;

import android.graphics.Canvas;

/**
 * Text renderer interface
 */

interface TextRenderer {
    public static final int MODE_OFF = 0;
    public static final int MODE_ON = 1;
    public static final int MODE_LOCKED = 2;
    public static final int MODE_MASK = 3;

    public static final int MODE_SHIFT_SHIFT = 0;
    public static final int MODE_ALT_SHIFT = 2;
    public static final int MODE_CTRL_SHIFT = 4;
    public static final int MODE_FN_SHIFT = 6;

    void setReverseVideo(boolean reverseVideo);
    float getCharacterWidth();
    int getCharacterHeight();
    /** @return pixels above top row of text to avoid looking cramped. */
    int getTopMargin();
    void drawTextRun(Canvas canvas, float x, float y,
            int lineOffset, int runWidth, char[] text,
            int index, int count, boolean cursor, int textStyle);
    void drawCursor(Canvas canvas, float x, float y, int lineOffset, int cursorMode);
}
package com.termx;

public final class TextStyle {
    // Effect bitmasks:
    final static int fxNormal = 0;
    final static int fxBold = 1; // Originally Bright
    //final static int fxFaint = 2;
    final static int fxItalic = 1 << 1;
    final static int fxUnderline = 1 << 2;
    final static int fxBlink = 1 << 3;
    final static int fxInverse = 1 << 4;
    final static int fxInvisible = 1 << 5;

    // Special color indices
    final static int ciForeground = 256; // VT100 text foreground color
    final static int ciBackground = 257; // VT100 text background color
    final static int ciCursor = 258;     // VT100 text cursor color

    final static int ciColorLength = ciCursor + 1;

    final static int kNormalTextStyle = encode(ciForeground, ciBackground, fxNormal);

    static int encode(int foreColor, int backColor, int effect) {
        return ((effect & 0x3f) << 18) | ((foreColor & 0x1ff) << 9) | (backColor & 0x1ff);
    }

    static int decodeForeColor(int encodedColor) {
        return (encodedColor >> 9) & 0x1ff;
    }

    static int decodeBackColor(int encodedColor) {
        return encodedColor & 0x1ff;
    }

    static int decodeEffect(int encodedColor) {
        return (encodedColor >> 18) & 0x3f;
    }
}

package com.termx;

import java.util.Arrays;
import android.graphics.Canvas;
import com.termx.GrowableIntArray;

/**
 * A TranscriptScreen is a screen that remembers data that's been scrolled. The
 * old data is stored in a ring buffer to minimize the amount of copying that
 * needs to be done. The transcript does its own drawing, to avoid having to
 * expose its internal data structures.
 */
class TranscriptScreen implements Screen {
    /**
     * The width of the transcript, in characters. Fixed at initialization.
     */
    private int mColumns;

    /**
     * The total number of rows in the transcript and the screen. Fixed at
     * initialization.
     */
    private int mTotalRows;

    /**
     * The number of rows in the screen.
     */
    private int mScreenRows;

    public UnicodeTranscript mData;
    
    /**
     * Create a transcript screen.
     *
     * @param columns the width of the screen in characters.
     * @param totalRows the height of the entire text area, in rows of text.
     * @param screenRows the height of just the screen, not including the
     *        transcript that holds lines that have scrolled off the top of the
     *        screen.
     */
    public TranscriptScreen(int columns, int totalRows, int screenRows,
            ColorScheme scheme) {
        init(columns, totalRows, screenRows, TextStyle.kNormalTextStyle);
    }

    private void init(int columns, int totalRows, int screenRows, int style) {
        mColumns = columns;
        mTotalRows = totalRows;
        mScreenRows = screenRows;

        mData = new UnicodeTranscript(columns, totalRows, screenRows, style);
        mData.blockSet(0, 0, mColumns, mScreenRows, ' ', style);
    }

    public void setColorScheme(ColorScheme scheme) {
        mData.setDefaultStyle(TextStyle.kNormalTextStyle);
    }

    public void finish() {
        /*
         * The Android InputMethodService will sometimes hold a reference to
         * us for a while after the activity closes, which is expensive because
         * it means holding on to the now-useless mData array.  Explicitly
         * get rid of our references to this data to help keep the amount of
         * memory being leaked down.
         */
        mData = null;
    }

    public void setLineWrap(int row) {
        mData.setLineWrap(row);
    }

    /**
     * Store a Unicode code point into the screen at location (x, y)
     *
     * @param x X coordinate (also known as column)
     * @param y Y coordinate (also known as row)
     * @param codePoint Unicode codepoint to store
     * @param foreColor the foreground color
     * @param backColor the background color
     */
    public void set(int x, int y, int codePoint, int style) {
        mData.setChar(x, y, codePoint, style);
    }

    public void set(int x, int y, byte b, int style) {
        mData.setChar(x, y, b, style);
    }

    /**
     * Scroll the screen down one line. To scroll the whole screen of a 24 line
     * screen, the arguments would be (0, 24).
     *
     * @param topMargin First line that is scrolled.
     * @param bottomMargin One line after the last line that is scrolled.
     * @param style the style for the newly exposed line.
     */
    public void scroll(int topMargin, int bottomMargin, int style) {
        mData.scroll(topMargin, bottomMargin, style);
    }

    /**
     * Block copy characters from one position in the screen to another. The two
     * positions can overlap. All characters of the source and destination must
     * be within the bounds of the screen, or else an InvalidParemeterException
     * will be thrown.
     *
     * @param sx source X coordinate
     * @param sy source Y coordinate
     * @param w width
     * @param h height
     * @param dx destination X coordinate
     * @param dy destination Y coordinate
     */
    public void blockCopy(int sx, int sy, int w, int h, int dx, int dy) {
        mData.blockCopy(sx, sy, w, h, dx, dy);
    }

    /**
     * Block set characters. All characters must be within the bounds of the
     * screen, or else and InvalidParemeterException will be thrown. Typically
     * this is called with a "val" argument of 32 to clear a block of
     * characters.
     *
     * @param sx source X
     * @param sy source Y
     * @param w width
     * @param h height
     * @param val value to set.
     */
    public void blockSet(int sx, int sy, int w, int h, int val,
            int style) {
        mData.blockSet(sx, sy, w, h, val, style);
    }

    /**
     * Draw a row of text. Out-of-bounds rows are blank, not errors.
     *
     * @param row The row of text to draw.
     * @param canvas The canvas to draw to.
     * @param x The x coordinate origin of the drawing
     * @param y The y coordinate origin of the drawing
     * @param renderer The renderer to use to draw the text
     * @param cx the cursor X coordinate, -1 means don't draw it
     * @param selx1 the text selection start X coordinate
     * @param selx2 the text selection end X coordinate, if equals to selx1 don't draw selection
     * @param imeText current IME text, to be rendered at cursor
     * @param cursorMode the cursor mode. See TextRenderer.
     */
    public final void drawText(int row, Canvas canvas, float x, float y,
            TextRenderer renderer, int cx, int selx1, int selx2, String imeText, int cursorMode) {
        char[] line;
        StyleRow color;
        try {
            line = mData.getLine(row);
            color = mData.getLineColor(row);
        } catch (IllegalArgumentException e) {
            // Out-of-bounds rows are blank.
            return;
        } catch (NullPointerException e) {
            // Attempt to draw on a finished transcript
            // XXX Figure out why this happens on Honeycomb
            return;
        }
        int defaultStyle = mData.getDefaultStyle();

        if (line == null) {
            // Line is blank.
            if (selx1 != selx2) {
                // We need to draw a selection
                char[] blank = new char[selx2-selx1];
                Arrays.fill(blank, ' ');
                renderer.drawTextRun(canvas, x, y, selx1, selx2-selx1,
                                blank, 0, 1, true, defaultStyle);
            } else if (cx != -1) {
                // We need to draw the cursor
                renderer.drawCursor(canvas, x, y, cx, cursorMode);
            }

            return;
        }

        int columns = mColumns;
        int lastStyle = 0;
        boolean lastCursorStyle = false;
        int runWidth = 0;
        int lastRunStart = -1;
        int lastRunStartIndex = -1;
        boolean forceFlushRun = false;
        int column = 0;
        int index = 0;
        while (column < columns) {
            int style = color.get(column);
            boolean cursorStyle = false;
            int incr = 1;
            int width;
            if (Character.isHighSurrogate(line[index])) {
                width = UnicodeTranscript.charWidth(line, index);
                incr++;
            } else {
                width = UnicodeTranscript.charWidth(line[index]);
            }
            if (column >= selx1 && column <= selx2) {
                // Set cursor background color:
                cursorStyle = true;
            }
            if (style != lastStyle
                    || cursorStyle != lastCursorStyle
                    || (width > 0 && forceFlushRun)) {
                if (lastRunStart >= 0) {
                    renderer.drawTextRun(canvas, x, y, lastRunStart, runWidth,
                            line,
                            lastRunStartIndex, index - lastRunStartIndex,
                            lastCursorStyle, lastStyle);
                }
                lastStyle = style;
                lastCursorStyle = cursorStyle;
                runWidth = 0;
                lastRunStart = column;
                lastRunStartIndex = index;
                forceFlushRun = false;
            }
            runWidth += width;
            column += width;
            index += incr;
            if (width > 1) {
                /* We cannot draw two or more East Asian wide characters in the
                   same run, because we need to make each wide character take
                   up two columns, which may not match the font's idea of the
                   character width */
                forceFlushRun = true;
            }
        }
        if (lastRunStart >= 0) {
            renderer.drawTextRun(canvas, x, y, lastRunStart, runWidth,
                    line,
                    lastRunStartIndex, index - lastRunStartIndex,
                    lastCursorStyle, lastStyle);
        }

        if (cx >= 0 && imeText.length() > 0) {
            int imeLength = Math.min(columns, imeText.length());
            int imeOffset = imeText.length() - imeLength;
            int imePosition = Math.min(cx, columns - imeLength);
            renderer.drawTextRun(canvas, x, y, imePosition, imeLength, imeText.toCharArray(),
                    imeOffset, imeLength, true, TextStyle.encode(0x0f, 0x00, TextStyle.fxNormal));
        }

        if (cx >= 0) {
            renderer.drawCursor(canvas,  x, y, cx, cursorMode);
        }
     }

    /**
     * Get the count of active rows.
     *
     * @return the count of active rows.
     */
    public int getActiveRows() {
        return mData.getActiveRows();
    }

    /**
     * Get the count of active transcript rows.
     *
     * @return the count of active transcript rows.
     */
    public int getActiveTranscriptRows() {
        return mData.getActiveTranscriptRows();
    }

    public String getTranscriptText() {
        return internalGetTranscriptText(null, 0, -mData.getActiveTranscriptRows(), mColumns, mScreenRows);
    }

    public String getTranscriptText(GrowableIntArray colors) {
        return internalGetTranscriptText(colors, 0, -mData.getActiveTranscriptRows(), mColumns, mScreenRows);
    }

    public String getSelectedText(int selX1, int selY1, int selX2, int selY2) {
        return internalGetTranscriptText(null, selX1, selY1, selX2, selY2);
    }

    public String getSelectedText(GrowableIntArray colors, int selX1, int selY1, int selX2, int selY2) {
        return internalGetTranscriptText(colors, selX1, selY1, selX2, selY2);
    }

    private String internalGetTranscriptText(GrowableIntArray colors, int selX1, int selY1, int selX2, int selY2) {
        StringBuilder builder = new StringBuilder();
        UnicodeTranscript data = mData;
        int columns = mColumns;
        char[] line;
        StyleRow rowColorBuffer = null;
        if (selY1 < -data.getActiveTranscriptRows()) {
            selY1 = -data.getActiveTranscriptRows();
        }
        if (selY2 >= mScreenRows) {
            selY2 = mScreenRows - 1;
        }
        for (int row = selY1; row <= selY2; row++) {
            int x1 = 0;
            int x2;
            if ( row == selY1 ) {
                x1 = selX1;
            }
            if ( row == selY2 ) {
                x2 = selX2 + 1;
                if (x2 > columns) {
                    x2 = columns;
                }
            } else {
                x2 = columns;
            }
            line = data.getLine(row, x1, x2);
            if (colors != null) {
                rowColorBuffer = data.getLineColor(row, x1, x2);
            }
            if (line == null) {
                if (!data.getLineWrap(row) && row < selY2 && row < mScreenRows - 1) {
                    builder.append('\n');
                    if (colors != null) {
                        colors.append(0);
                    }
                }
                continue;
            }
            int defaultColor = mData.getDefaultStyle();
            int lastPrintingChar = -1;
            int lineLen = line.length;
            int i;
            int width = x2 - x1;
            int column = 0;
            for (i = 0; i < lineLen && column < width; ++i) {
                char c = line[i];
                if (c == 0) {
                    break;
                } else if (c != ' ' || ((rowColorBuffer != null) && (rowColorBuffer.get(column) != defaultColor))) {
                    lastPrintingChar = i;
                }
                if (!Character.isLowSurrogate(c)) {
                    column += UnicodeTranscript.charWidth(line, i);
                }
            }
            if (data.getLineWrap(row) && lastPrintingChar > -1 && x2 == columns) {
                // If the line was wrapped, we shouldn't lose trailing space
                lastPrintingChar = i - 1;
            }
            builder.append(line, 0, lastPrintingChar + 1);
            if (colors != null) {
                if (rowColorBuffer != null) {
                    column = 0;
                    for (int j = 0; j <= lastPrintingChar; ++j) {
                        colors.append(rowColorBuffer.get(column));
                        column += UnicodeTranscript.charWidth(line, j);
                        if (Character.isHighSurrogate(line[j])) {
                            ++j;
                        }
                    }
                } else {
                    for (int j = 0; j <= lastPrintingChar; ++j) {
                        colors.append(defaultColor);
                        char c = line[j];
                        if (Character.isHighSurrogate(c)) {
                            ++j;
                        }
                    }
                }
            }
            if (!data.getLineWrap(row) && row < selY2 && row < mScreenRows - 1) {
                builder.append('\n');
                if (colors != null) {
                    colors.append((char) 0);
                }
            }
        }
        return builder.toString();
    }

    public boolean fastResize(int columns, int rows, int[] cursor) {
        if (mData == null) {
            // XXX Trying to resize a finished TranscriptScreen?
            return true;
        }
        if (mData.resize(columns, rows, cursor)) {
            mColumns = columns;
            mScreenRows = rows;
            return true;
        } else {
            return false;
        }
    }

    public void resize(int columns, int rows, int style) {
        init(columns, mTotalRows, rows, style);
    }
    
    /**
     * 
     * Return the UnicodeTranscript line at this row index.
     * @param row The row index to be queried
     * @return The line of text at this row index
     */
    public char[] getScriptLine(int row)
    {
    	try
    	{
    		return mData.getLine(row);
    	}
    	catch (IllegalArgumentException e)
    	{
    		return null;
    	}
    	catch (NullPointerException e)
    	{
    		return null;
    	}
    }
    
    /**
     * Get the line wrap status of the row provided.
     * @param row The row to check for line-wrap status
     * @return The line wrap status of the row provided
     */
    public boolean getScriptLineWrap(int row)
    {
    	return mData.getLineWrap(row);
    }
}
package com.termx;

import android.util.Log;
import com.termx.AndroidCharacterCompat;

/**
 * A backing store for a TranscriptScreen.
 *
 * The text is stored as a circular buffer of rows.  There are two types of
 * row:
 * - "basic", which is a char[] array used to store lines which consist
 *   entirely of regular-width characters (no combining characters, zero-width
 *   characters, East Asian double-width characters, etc.) in the BMP; and
 * - "full", which is a char[] array with extra trappings which can be used to
 *   store a line containing any valid Unicode sequence.  An array of short[]
 *   is used to store the "offset" at which each column starts; for example,
 *   if column 20 starts at index 23 in the array, then mOffset[20] = 3.
 *
 * Style information is stored in a separate circular buffer of StyleRows.
 *
 * Rows are allocated on demand, when a character is first stored into them.
 * A "basic" row is allocated unless the store which triggers the allocation
 * requires a "full" row.  "Basic" rows are converted to "full" rows when
 * needed.  There is no conversion in the other direction -- a "full" row
 * stays that way even if it contains only regular-width BMP characters.
 */
class UnicodeTranscript {
    private static final String TAG = "UnicodeTranscript";

    private Object[] mLines;
    private StyleRow[] mColor;
    private boolean[] mLineWrap;
    private int mTotalRows;
    private int mScreenRows;
    private int mColumns;
    private int mActiveTranscriptRows = 0;
    private int mDefaultStyle = 0;

    private int mScreenFirstRow = 0;

    private char[] tmpLine;
    private StyleRow tmpColor;

    public UnicodeTranscript(int columns, int totalRows, int screenRows, int defaultStyle) {
        mColumns = columns;
        mTotalRows = totalRows;
        mScreenRows = screenRows;
        mLines = new Object[totalRows];
        mColor = new StyleRow[totalRows];
        mLineWrap = new boolean[totalRows];
        tmpColor = new StyleRow(defaultStyle, mColumns);

        mDefaultStyle = defaultStyle;
    }

    public void setDefaultStyle(int defaultStyle) {
        mDefaultStyle = defaultStyle;
    }

    public int getDefaultStyle() {
        return mDefaultStyle;
    }

    public int getActiveTranscriptRows() {
        return mActiveTranscriptRows;
    }

    public int getActiveRows() {
        return mActiveTranscriptRows + mScreenRows;
    }

    /**
     * Convert a row value from the public external coordinate system to our
     * internal private coordinate system.
     * External coordinate system:
     * -mActiveTranscriptRows to mScreenRows-1, with the screen being
     * 0..mScreenRows-1
     * Internal coordinate system: the mScreenRows lines starting at
     * mScreenFirstRow comprise the screen, while the mActiveTranscriptRows
     * lines ending at mScreenRows-1 form the transcript (as a circular
     * buffer).
     *
     * @param extRow a row in the external coordinate system.
     * @return The row corresponding to the input argument in the private
     *         coordinate system.
     */
    private int externalToInternalRow(int extRow) {
        if (extRow < -mActiveTranscriptRows || extRow > mScreenRows) {
            String errorMessage = "externalToInternalRow "+ extRow +
                " " + mScreenRows + " " + mActiveTranscriptRows;
            Log.e(TAG, errorMessage);
            throw new IllegalArgumentException(errorMessage);
        }

        if (extRow >= 0) {
            return (mScreenFirstRow + extRow) % mTotalRows;
        } else {
            if (-extRow > mScreenFirstRow) {
                return mTotalRows + mScreenFirstRow + extRow;
            } else {
                return mScreenFirstRow + extRow;
            }
        }
    }

    public void setLineWrap(int row) {
        mLineWrap[externalToInternalRow(row)] = true;
    }

    public boolean getLineWrap(int row) {
        return mLineWrap[externalToInternalRow(row)];
    }

    /**
     * Resize the screen which this transcript backs.  Currently, this
     * only works if the number of columns does not change.
     *
     * @param newColumns The number of columns the screen should have.
     * @param newRows The number of rows the screen should have.
     * @param cursor An int[2] containing the cursor location.
     * @return Whether or not the resize succeeded.  If the resize failed,
     *         the caller may "resize" the screen by copying out all the data
     *         and placing it into a new transcript of the correct size.
     */
    public boolean resize(int newColumns, int newRows, int[] cursor) {
        if (newColumns != mColumns || newRows > mTotalRows) {
            return false;
        }

        int screenRows = mScreenRows;
        int activeTranscriptRows = mActiveTranscriptRows;
        int shift = screenRows - newRows;
        if (shift < -activeTranscriptRows) {
            // We want to add blank lines at the bottom instead of at the top
            Object[] lines = mLines;
            Object[] color = mColor;
            boolean[] lineWrap = mLineWrap;
            int screenFirstRow = mScreenFirstRow;
            int totalRows = mTotalRows;
            for (int i = 0; i < activeTranscriptRows - shift; ++i) {
                int index = (screenFirstRow + screenRows + i) % totalRows;
                lines[index] = null;
                color[index] = null;
                lineWrap[index] = false;
            }
            shift = -activeTranscriptRows;
        } else if (shift > 0 && cursor[1] != screenRows - 1) {
            /* When shrinking the screen, we want to hide blank lines at the
               bottom in preference to lines at the top of the screen */
            Object[] lines = mLines;
            for (int i = screenRows - 1; i > cursor[1]; --i) {
                int index = externalToInternalRow(i);
                if (lines[index] == null) {
                    // Line is blank
                    --shift;
                    if (shift == 0) {
                        break;
                    } else {
                        continue;
                    }
                }

                char[] line;
                if (lines[index] instanceof char[]) {
                    line = (char[]) lines[index];
                } else {
                    line = ((FullUnicodeLine) lines[index]).getLine();
                }

                int len = line.length;
                int j;
                for (j = 0; j < len; ++j) {
                    if (line[j] == 0) {
                        // We've reached the end of the line
                        j = len;
                        break;
                    } else if (line[j] != ' ') {
                        // Line is not blank
                        break;
                    }
                }

                if (j == len) {
                    // Line is blank
                    --shift;
                    if (shift == 0) {
                        break;
                    } else {
                        continue;
                    }
                } else {
                    // Line not blank -- we keep it and everything above
                    break;
                }
            }
        }

        if (shift > 0 || (shift < 0 && mScreenFirstRow >= -shift)) {
            // All we're doing is moving the top of the screen.
            mScreenFirstRow = (mScreenFirstRow + shift) % mTotalRows;
        } else if (shift < 0) {
            // The new top of the screen wraps around the top of the array.
            mScreenFirstRow = mTotalRows + mScreenFirstRow + shift;
        }

        if (mActiveTranscriptRows + shift < 0) {
            mActiveTranscriptRows = 0;
        } else {
            mActiveTranscriptRows += shift;
        }
        cursor[1] -= shift;
        mScreenRows = newRows;

        return true;
    }

    /**
     * Block copy lines and associated metadata from one location to another
     * in the circular buffer, taking wraparound into account.
     *
     * @param src The first line to be copied.
     * @param len The number of lines to be copied.
     * @param shift The offset of the destination from the source.
     */
    private void blockCopyLines(int src, int len, int shift) {
        int totalRows = mTotalRows;

        int dst;
        if (src + shift >= 0) {
            dst = (src + shift) % totalRows;
        } else {
            dst = totalRows + src + shift;
        }

        if (src + len <= totalRows && dst + len <= totalRows) {
            // Fast path -- no wraparound
            System.arraycopy(mLines, src, mLines, dst, len);
            System.arraycopy(mColor, src, mColor, dst, len);
            System.arraycopy(mLineWrap, src, mLineWrap, dst, len);
            return;
        }

        if (shift < 0) {
            // Do the copy from top to bottom
            for (int i = 0; i < len; ++i) {
                mLines[(dst + i) % totalRows] = mLines[(src + i) % totalRows];
                mColor[(dst + i) % totalRows] = mColor[(src + i) % totalRows];
                mLineWrap[(dst + i) % totalRows] = mLineWrap[(src + i) % totalRows];
            }
        } else {
            // Do the copy from bottom to top
            for (int i = len - 1; i >= 0; --i) {
                mLines[(dst + i) % totalRows] = mLines[(src + i) % totalRows];
                mColor[(dst + i) % totalRows] = mColor[(src + i) % totalRows];
                mLineWrap[(dst + i) % totalRows] = mLineWrap[(src + i) % totalRows];
            }
        }
    }

    /**
     * Scroll the screen down one line. To scroll the whole screen of a 24 line
     * screen, the arguments would be (0, 24).
     *
     * @param topMargin First line that is scrolled.
     * @param bottomMargin One line after the last line that is scrolled.
     * @param style the style for the newly exposed line.
     */
    public void scroll(int topMargin, int bottomMargin, int style) {
        // Separate out reasons so that stack crawls help us
        // figure out which condition was violated.
        if (topMargin > bottomMargin - 1) {
            throw new IllegalArgumentException();
        }

        if (topMargin < 0)  {
            throw new IllegalArgumentException();
        }

        if (bottomMargin > mScreenRows) {
            throw new IllegalArgumentException();
        }

        int screenRows = mScreenRows;
        int totalRows = mTotalRows;

        if (topMargin == 0 && bottomMargin == screenRows) {
            // Fast path -- scroll the entire screen
            mScreenFirstRow = (mScreenFirstRow + 1) % totalRows;
            if (mActiveTranscriptRows < totalRows - screenRows) {
                ++mActiveTranscriptRows;
            }

            // Blank the bottom margin
            int blankRow = externalToInternalRow(bottomMargin - 1);
            mLines[blankRow] = null;
            mColor[blankRow] = new StyleRow(style, mColumns);
            mLineWrap[blankRow] = false;

            return;
        }

        int screenFirstRow = mScreenFirstRow;
        int topMarginInt = externalToInternalRow(topMargin);
        int bottomMarginInt = externalToInternalRow(bottomMargin);

        /* Save the scrolled line, move the lines above it on the screen down
           one line, move the lines on screen below the bottom margin down
           one line, then insert the scrolled line into the transcript */
        Object[] lines = mLines;
        StyleRow[] color = mColor;
        boolean[] lineWrap = mLineWrap;
        Object scrollLine = lines[topMarginInt];
        StyleRow scrollColor = color[topMarginInt];
        boolean scrollLineWrap = lineWrap[topMarginInt];
        blockCopyLines(screenFirstRow, topMargin, 1);
        blockCopyLines(bottomMarginInt, screenRows - bottomMargin, 1);
        lines[screenFirstRow] = scrollLine;
        color[screenFirstRow] = scrollColor;
        lineWrap[screenFirstRow] = scrollLineWrap;

        // Update the screen location
        mScreenFirstRow = (screenFirstRow + 1) % totalRows;
        if (mActiveTranscriptRows < totalRows - screenRows) {
            ++mActiveTranscriptRows;
        }

        // Blank the bottom margin
        int blankRow = externalToInternalRow(bottomMargin - 1);
        lines[blankRow] = null;
        color[blankRow] = new StyleRow(style, mColumns);
        lineWrap[blankRow] = false;

        return;
    }

    /**
     * Block copy characters from one position in the screen to another. The two
     * positions can overlap. All characters of the source and destination must
     * be within the bounds of the screen, or else an InvalidParameterException
     * will be thrown.
     *
     * @param sx source X coordinate
     * @param sy source Y coordinate
     * @param w width
     * @param h height
     * @param dx destination X coordinate
     * @param dy destination Y coordinate
     */
    public void blockCopy(int sx, int sy, int w, int h, int dx, int dy) {
        if (sx < 0 || sx + w > mColumns || sy < 0 || sy + h > mScreenRows
                || dx < 0 || dx + w > mColumns || dy < 0
                || dy + h > mScreenRows) {
            throw new IllegalArgumentException();
        }
        Object[] lines = mLines;
        StyleRow[] color = mColor;
        if (sy > dy) {
            // Move in increasing order
            for (int y = 0; y < h; y++) {
                int srcRow = externalToInternalRow(sy + y);
                int dstRow = externalToInternalRow(dy + y);
                if (lines[srcRow] instanceof char[] && lines[dstRow] instanceof char[]) {
                    System.arraycopy(lines[srcRow], sx, lines[dstRow], dx, w);
                } else {
                    // XXX There has to be a faster way to do this ...
                    int extDstRow = dy + y;
                    char[] tmp = getLine(sy + y, sx, sx + w);
                    if (tmp == null) {
                        // Source line was blank
                        blockSet(dx, extDstRow, w, 1, ' ', mDefaultStyle);
                        continue;
                    }
                    char cHigh = 0;
                    int x = 0;
                    int columns = mColumns;
                    for (int i = 0; i < tmp.length; ++i) {
                        if (tmp[i] == 0 || dx + x >= columns) {
                            break;
                        }
                        if (Character.isHighSurrogate(tmp[i])) {
                            cHigh = tmp[i];
                            continue;
                        } else if (Character.isLowSurrogate(tmp[i])) {
                            int codePoint = Character.toCodePoint(cHigh, tmp[i]);
                            setChar(dx + x, extDstRow, codePoint);
                            x += charWidth(codePoint);
                        } else {
                            setChar(dx + x, extDstRow, tmp[i]);
                            x += charWidth(tmp[i]);
                        }
                    }
                }
                color[srcRow].copy(sx, color[dstRow], dx, w);
            }
        } else {
            // Move in decreasing order
            for (int y = 0; y < h; y++) {
                int y2 = h - (y + 1);
                int srcRow = externalToInternalRow(sy + y2);
                int dstRow = externalToInternalRow(dy + y2);
                if (lines[srcRow] instanceof char[] && lines[dstRow] instanceof char[]) {
                    System.arraycopy(lines[srcRow], sx, lines[dstRow], dx, w);
                } else {
                    int extDstRow = dy + y2;
                    char[] tmp = getLine(sy + y2, sx, sx + w);
                    if (tmp == null) {
                        // Source line was blank
                        blockSet(dx, extDstRow, w, 1, ' ', mDefaultStyle);
                        continue;
                    }
                    char cHigh = 0;
                    int x = 0;
                    int columns = mColumns;
                    for (int i = 0; i < tmp.length; ++i) {
                        if (tmp[i] == 0 || dx + x >= columns) {
                            break;
                        }
                        if (Character.isHighSurrogate(tmp[i])) {
                            cHigh = tmp[i];
                            continue;
                        } else if (Character.isLowSurrogate(tmp[i])) {
                            int codePoint = Character.toCodePoint(cHigh, tmp[i]);
                            setChar(dx + x, extDstRow, codePoint);
                            x += charWidth(codePoint);
                        } else {
                            setChar(dx + x, extDstRow, tmp[i]);
                            x += charWidth(tmp[i]);
                        }
                    }
                }
                color[srcRow].copy(sx, color[dstRow], dx, w);
            }
        }
    }

    /**
     * Block set characters. All characters must be within the bounds of the
     * screen, or else and InvalidParemeterException will be thrown. Typically
     * this is called with a "val" argument of 32 to clear a block of
     * characters.
     *
     * @param sx source X
     * @param sy source Y
     * @param w width
     * @param h height
     * @param val value to set.
     */
    public void blockSet(int sx, int sy, int w, int h, int val, int style) {
        if (sx < 0 || sx + w > mColumns || sy < 0 || sy + h > mScreenRows) {
            Log.e(TAG, "illegal arguments! " + sx + " " + sy + " " + w + " " + h + " " + val + " " + mColumns + " " + mScreenRows);
            throw new IllegalArgumentException();
        }

        for (int y = 0; y < h; y++) {
            for (int x = 0; x < w; x++) {
                setChar(sx + x, sy + y, val, style);
            }
        }
    }

    /**
     * Gives the display width of the code point in a monospace font.
     *
     * Nonspacing combining marks, format characters, and control characters
     * have display width zero.  East Asian fullwidth and wide characters
     * have display width two.  All other characters have display width one.
     *
     * Known issues:
     * - Proper support for East Asian wide characters requires API >= 8.
     * - Results are incorrect for individual Hangul jamo (a syllable block
     *   of jamo should be one unit with width 2).  This does not affect
     *   precomposed Hangul syllables.
     * - Assigning all East Asian "ambiguous" characters a width of 1 may not
     *   be correct if Android renders those characters as wide in East Asian
     *   context (as the Unicode standard permits).
     *
     * @param codePoint A Unicode code point.
     * @return The display width of the Unicode code point.
     */
    public static int charWidth(int codePoint) {
        // Early out for ASCII printable characters
        if (codePoint > 31 && codePoint < 127) {
            return 1;
        }

        /* HACK: We're using ASCII ESC to save the location of the cursor
           across screen resizes, so we need to pretend that it has width 1 */
        if (codePoint == 27) {
            return 1;
        }

        switch (Character.getType(codePoint)) {
        case Character.CONTROL:
        case Character.FORMAT:
        case Character.NON_SPACING_MARK:
        case Character.ENCLOSING_MARK:
            return 0;
        }

        if (Character.charCount(codePoint) == 1) {
            // Android's getEastAsianWidth() only works for BMP characters
            switch (AndroidCharacterCompat.getEastAsianWidth((char) codePoint)) {
            case AndroidCharacterCompat.EAST_ASIAN_WIDTH_FULL_WIDTH:
            case AndroidCharacterCompat.EAST_ASIAN_WIDTH_WIDE:
                return 2;
            }
        } else {
            // Outside the BMP, only the ideographic planes contain wide chars
            switch ((codePoint >> 16) & 0xf) {
            case 2: // Supplementary Ideographic Plane
            case 3: // Tertiary Ideographic Plane
                return 2;
            }
        }

        return 1;
    }

    public static int charWidth(char cHigh, char cLow) {
        return charWidth(Character.toCodePoint(cHigh, cLow));
    }

    /**
     * Gives the display width of a code point in a char array
     * in a monospace font.
     *
     * @param chars The array containing the code point in question.
     * @param index The index into the array at which the code point starts.
     * @return The display width of the Unicode code point.
     */
    public static int charWidth(char[] chars, int index) {
        char c = chars[index];
        if (Character.isHighSurrogate(c)) {
            return charWidth(c, chars[index+1]);
        } else {
            return charWidth(c);
        }
    }

    /**
     * Get the contents of a line (or part of a line) of the transcript.
     *
     * The char[] array returned may be part of the internal representation
     * of the line -- make a copy first if you want to modify it.  The last
     * character requested will be followed by a NUL; the contents of the rest
     * of the array could potentially be garbage.
     *
     * @param row The row number to get (-mActiveTranscriptRows..mScreenRows-1)
     * @param x1 The first screen position that's wanted
     * @param x2 One after the last screen position that's wanted
     * @return A char[] array containing the requested contents
     */
    public char[] getLine(int row, int x1, int x2) {
        if (row < -mActiveTranscriptRows || row > mScreenRows-1) {
            throw new IllegalArgumentException();
        }

        int columns = mColumns;
        row = externalToInternalRow(row);
        if (mLines[row] == null) {
            // Line is blank
            return null;
        }
        if (mLines[row] instanceof char[]) {
            // Line contains only regular-width BMP characters
            if (x1 == 0 && x2 == columns) {
                // Want the whole row? Easy.
                return (char[]) mLines[row];
            } else {
                if (tmpLine == null || tmpLine.length < columns + 1) {
                    tmpLine = new char[columns+1];
                }
                int length = x2 - x1;
                System.arraycopy(mLines[row], x1, tmpLine, 0, length);
                tmpLine[length] = 0;
                return tmpLine;
            }
        }

        // Figure out how long the array needs to be
        FullUnicodeLine line = (FullUnicodeLine) mLines[row];
        char[] rawLine = line.getLine();
        x1 = line.findStartOfColumn(x1);
        if (x2 < columns) {
            x2 = line.findStartOfColumn(x2);
        } else {
            x2 = line.getSpaceUsed();
        }
        int length = x2 - x1;

        if (tmpLine == null || tmpLine.length < length + 1) {
            tmpLine = new char[length+1];
        }
        System.arraycopy(rawLine, x1, tmpLine, 0, length);
        tmpLine[length] = 0;
        return tmpLine;
    }

    public char[] getLine(int row) {
        return getLine(row, 0, mColumns);
    }

    /**
     * Get color/formatting information for a particular line.
     * The returned object may be a pointer to a temporary buffer, only good
     * until the next call to getLineColor.
     */
    public StyleRow getLineColor(int row, int x1, int x2) {
        if (row < -mActiveTranscriptRows || row > mScreenRows-1) {
            throw new IllegalArgumentException();
        }

        row = externalToInternalRow(row);
        StyleRow color = mColor[row];
        StyleRow tmp = tmpColor;
        if (color != null) {
            if (x1 == 0 && x2 == mColumns) {
                return color;
            }
            color.copy(x1, tmp, 0, x2-x1);
            return tmp;
        } else {
            return null;
        }
    }

    public StyleRow getLineColor(int row) {
        return getLineColor(row, 0, mColumns);
    }

    public boolean getChar(int row, int column) {
        return getChar(row, column, 0);
    }

    public boolean getChar(int row, int column, int charIndex) {
        return getChar(row, column, charIndex, new char[1], 0);
    }

    /**
     * Get a character at a specific position in the transcript.
     *
     * @param row The row of the character to get.
     * @param column The column of the character to get.
     * @param charIndex The index of the character in the column to get
     *  (0 for the first character, 1 for the next, etc.)
     * @param out The char[] array into which the character will be placed.
     * @param offset The offset in the array at which the character will be placed.
     * @return Whether or not there are characters following this one in the column.
     */
    public boolean getChar(int row, int column, int charIndex, char[] out, int offset) {
        if (row < -mActiveTranscriptRows || row > mScreenRows-1) {
            throw new IllegalArgumentException();
        }
        row = externalToInternalRow(row);

        if (mLines[row] instanceof char[]) {
            // Fast path: all regular-width BMP chars in the row
            char[] line = (char[]) mLines[row];
            out[offset] = line[column];
            return false;
        }

        FullUnicodeLine line = (FullUnicodeLine) mLines[row];
        return line.getChar(column, charIndex, out, offset);
    }

    private boolean isBasicChar(int codePoint) {
        return !(charWidth(codePoint) != 1 || Character.charCount(codePoint) != 1);
    }

    private char[] allocateBasicLine(int row, int columns) {
        char[] line = new char[columns];

        // Fill the line with blanks
        for (int i = 0; i < columns; ++i) {
            line[i] = ' ';
        }

        mLines[row] = line;
        if (mColor[row] == null) {
            mColor[row] = new StyleRow(0, columns);
        }
        return line;
    }

    private FullUnicodeLine allocateFullLine(int row, int columns) {
        FullUnicodeLine line = new FullUnicodeLine(columns);

        mLines[row] = line;
        if (mColor[row] == null) {
            mColor[row] = new StyleRow(0, columns);
        }
        return line;
    }

    public boolean setChar(int column, int row, int codePoint, int style) {
        if (!setChar(column, row, codePoint)) {
            return false;
        }

        row = externalToInternalRow(row);
        mColor[row].set(column, style);

        return true;
    }

    public boolean setChar(int column, int row, int codePoint) {
        if (row >= mScreenRows || column >= mColumns) {
            Log.e(TAG, "illegal arguments! " + row + " " + column + " " + mScreenRows + " " + mColumns);
            throw new IllegalArgumentException();
        }
        row = externalToInternalRow(row);

        /*
         * Whether data contains non-BMP or characters with charWidth != 1
         * 0 - false; 1 - true; -1 - undetermined
         */
        int basicMode = -1;

        // Allocate a row on demand
        if (mLines[row] == null) {
            if (isBasicChar(codePoint)) {
                allocateBasicLine(row, mColumns);
                basicMode = 1;
            } else {
                allocateFullLine(row, mColumns);
                basicMode = 0;
            }
        }

        if (mLines[row] instanceof char[]) {
            char[] line = (char[]) mLines[row];

            if (basicMode == -1) {
                if (isBasicChar(codePoint)) {
                    basicMode = 1;
                } else {
                    basicMode = 0;
                }
            }

            if (basicMode == 1) {
                // Fast path -- just put the char in the array
                line[column] = (char) codePoint;
                return true;
            }

            // Need to switch to the full-featured mode
            mLines[row] = new FullUnicodeLine(line);
        }

        FullUnicodeLine line = (FullUnicodeLine) mLines[row];
        line.setChar(column, codePoint);
        return true;
    }
}

/*
 * A representation of a line that's capable of handling non-BMP characters,
 * East Asian wide characters, and combining characters.
 *
 * The text of the line is stored in an array of char[], allowing easy
 * conversion to a String and/or reuse by other string-handling functions.
 * An array of short[] is used to keep track of the difference between a column
 * and the starting index corresponding to its contents in the char[] array (so
 * if column 42 starts at index 45 in the char[] array, the offset stored is 3).
 * Column 0 always starts at index 0 in the char[] array, so we use that
 * element of the array to keep track of how much of the char[] array we're
 * using at the moment.
 */
class FullUnicodeLine {
    private static final float SPARE_CAPACITY_FACTOR = 1.5f;

    private char[] mText;
    private short[] mOffset;
    private int mColumns;

    public FullUnicodeLine(int columns) {
        commonConstructor(columns);
        char[] text = mText;
        // Fill in the line with blanks
        for (int i = 0; i < columns; ++i) {
            text[i] = ' ';
        }
        // Store the space used
        mOffset[0] = (short) columns;
    }

    public FullUnicodeLine(char[] basicLine) {
        commonConstructor(basicLine.length);
        System.arraycopy(basicLine, 0, mText, 0, mColumns);
        // Store the space used
        mOffset[0] = (short) basicLine.length;
    }

    private void commonConstructor(int columns) {
        mColumns = columns;
        mOffset = new short[columns];
        mText = new char[(int)(SPARE_CAPACITY_FACTOR*columns)];
    }

    public int getSpaceUsed() {
        return mOffset[0];
    }

    public char[] getLine() {
        return mText;
    }

    public int findStartOfColumn(int column) {
        if (column == 0) {
            return 0;
        } else {
            return column + mOffset[column];
        }
    }

    public boolean getChar(int column, int charIndex, char[] out, int offset) {
        int pos = findStartOfColumn(column);
        int length;
        if (column + 1 < mColumns) {
            length = findStartOfColumn(column + 1) - pos;
        } else {
            length = getSpaceUsed() - pos;
        }
        if (charIndex >= length) {
            throw new IllegalArgumentException();
        }
        out[offset] = mText[pos + charIndex];
        return (charIndex + 1 < length);
    }

    public void setChar(int column, int codePoint) {
        int columns = mColumns;
        if (column < 0 || column >= columns) {
            throw new IllegalArgumentException();
        }

        char[] text = mText;
        short[] offset = mOffset;
        int spaceUsed = offset[0];

        int pos = findStartOfColumn(column);

        int charWidth = UnicodeTranscript.charWidth(codePoint);
        int oldCharWidth = UnicodeTranscript.charWidth(text, pos);

        // Get the number of elements in the mText array this column uses now
        int oldLen;
        if (column + oldCharWidth < columns) {
            oldLen = findStartOfColumn(column+oldCharWidth) - pos;
        } else {
            oldLen = spaceUsed - pos;
        }

        // Find how much space this column will need
        int newLen = Character.charCount(codePoint);
        if (charWidth == 0) {
            /* Combining characters are added to the contents of the column
               instead of overwriting them, so that they modify the existing
               contents */
            newLen += oldLen;
        }
        int shift = newLen - oldLen;

        // Shift the rest of the line right to make room if necessary
        if (shift > 0) {
            if (spaceUsed + shift > text.length) {
                // We need to grow the array
                char[] newText = new char[text.length + columns];
                System.arraycopy(text, 0, newText, 0, pos);
                System.arraycopy(text, pos + oldLen, newText, pos + newLen, spaceUsed - pos - oldLen);
                mText = text = newText;
            } else {
                System.arraycopy(text, pos + oldLen, text, pos + newLen, spaceUsed - pos - oldLen);
            }
        }

        // Store the character
        if (charWidth > 0) {
            Character.toChars(codePoint, text, pos);
        } else {
            /* Store a combining character at the end of the existing contents,
               so that it modifies them */
            Character.toChars(codePoint, text, pos + oldLen);
        }

        // Shift the rest of the line left to eliminate gaps if necessary
        if (shift < 0) {
            System.arraycopy(text, pos + oldLen, text, pos + newLen, spaceUsed - pos - oldLen);
        }

        // Update space used
        if (shift != 0) {
            spaceUsed += shift;
            offset[0] = (short) spaceUsed;
        }

        /*
         * Handle cases where charWidth changes
         * width 1 -> width 2: should clobber the contents of the next
         * column (if next column contains wide char, need to pad with a space)
         * width 2 -> width 1: pad with a space after the new character
         */
        if (oldCharWidth == 2 && charWidth == 1) {
            // Pad with a space
            int nextPos = pos + newLen;
            if (spaceUsed + 1 > text.length) {
                // Array needs growing
                char[] newText = new char[text.length + columns];
                System.arraycopy(text, 0, newText, 0, nextPos);

                System.arraycopy(text, nextPos, newText, nextPos + 1, spaceUsed - nextPos);
                mText = text = newText;
            } else {
                System.arraycopy(text, nextPos, text, nextPos + 1, spaceUsed - nextPos);
            }
            text[nextPos] = ' ';

            // Update space used
            ++offset[0];

            // Correct the offset for the next column to reflect width change
            if (column == 0) {
                offset[1] = (short) (newLen - 1);
            } else if (column + 1 < columns) {
                offset[column + 1] = (short) (offset[column] + newLen - 1);
            }
            ++column;
            ++shift;
        } else if (oldCharWidth == 1 && charWidth == 2) {
            if (column == columns - 1) {
                // A width 2 character doesn't fit in the last column.
                text[pos] = ' ';
                offset[0] = (short) (pos + 1);
                shift = 0;
            } else if (column == columns - 2) {
                // Correct offset for the next column to reflect width change
                offset[column + 1] = (short) (offset[column] - 1);

                // Truncate the line after this character.
                offset[0] = (short) (pos + newLen);
                shift = 0;
            } else {
                // Overwrite the contents of the next column.
                int nextPos = pos + newLen;
                int nextWidth = UnicodeTranscript.charWidth(text, nextPos);
                int nextLen;
                if (column + nextWidth + 1 < columns) {
                    nextLen = findStartOfColumn(column + nextWidth + 1) + shift - nextPos;
                } else {
                    nextLen = spaceUsed - nextPos;
                }

                if (nextWidth == 2) {
                    text[nextPos] = ' ';
                    // Shift the array to match
                    if (nextLen > 1) {
                        System.arraycopy(text, nextPos + nextLen, text, nextPos + 1, spaceUsed - nextPos - nextLen);
                        shift -= nextLen - 1;
                        offset[0] -= nextLen - 1;
                    }
                } else {
                    // Shift the array leftwards
                    System.arraycopy(text, nextPos + nextLen, text, nextPos, spaceUsed - nextPos - nextLen);
                    shift -= nextLen;

                    // Truncate the line
                    offset[0] -= nextLen;
                }

                // Correct the offset for the next column to reflect width change
                if (column == 0) {
                    offset[1] = -1;
                } else {
                    offset[column + 1] = (short) (offset[column] - 1);
                }
                ++column;
            }
        }

        // Update offset table
        if (shift != 0) {
            for (int i = column + 1; i < columns; ++i) {
                offset[i] += shift;
            }
        }
    }
}

/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.termx;

/**
 * Generic callback to be invoked to notify of updates.
 */
public interface UpdateCallback {
    /**
     * Callback function to be invoked when an update happens.
     */
    void onUpdate();
}
package com.termx;

import java.io.FileDescriptor;

public class execlib {
    static { System.loadLibrary("execpty"); }
    public static native FileDescriptor createSubprocess(
        String cmd, String[] arg0, String[] arg1, int[] processId);
        
    public static native void setPtyWindowSize(FileDescriptor fd,
       int row, int col, int xpixel, int ypixel);

    public static native int waitFor(int processId);

    public static native void close(FileDescriptor fd);

    public static native void hangupProcessGroup(int processId);
}

package com.termx;

import java.io.FileOutputStream;
import java.io.IOException;

import android.util.Log;
import com.termx.TranscriptScreen;



public class termemu {
 private final String TAG="com.termx";
    private int mCursorRow;
    private int mCursorCol;
    private int mRows;
    private int mColumns;
    private FileOutputStream mTermOut;
    private TranscriptScreen mScreen;
    private int mArgIndex;
    private static final int MAX_ESCAPE_PARAMETERS = 16;
    private int[] mArgs = new int[MAX_ESCAPE_PARAMETERS];

    private static final int ESC_NONE = 0;
    private static final int ESC = 1;
    private static final int ESC_POUND = 2;
    private static final int ESC_SELECT_LEFT_PAREN = 3;
    private static final int ESC_SELECT_RIGHT_PAREN = 4;
    private static final int ESC_LEFT_SQUARE_BRACKET = 5;
    private static final int ESC_LEFT_SQUARE_BRACKET_QUESTION_MARK = 6;
    private boolean mContinueSequence;
    private int mEscapeState;
    private int mSavedCursorRow;
    private int mSavedCursorCol;
    private static final int K_132_COLUMN_MODE_MASK = 1 << 3;
    private static final int K_ORIGIN_MODE_MASK = 1 << 6;
    private static final int K_WRAPAROUND_MODE_MASK = 1 << 7;
    private int mDecFlags;

    private int mSavedDecFlags;

    private boolean mInsertMode;
    private boolean mAutomaticNewlineMode;

    private boolean[] mTabStop;

    private int mTopMargin;

    private int mBottomMargin;

    private boolean mAboutToAutoWrap;

    private int mProcessedCharCount;

    private int mForeColor;

    private int mBackColor;

    private boolean mInverseColors;

    private boolean mbKeypadApplicationMode;

    private boolean mAlternateCharSet;

    private int mScrollCounter = 0;

    public termemu (TranscriptScreen screen, int columns, int rows,
            FileOutputStream termOut) {
        mScreen = screen;
        mRows = rows;
        mColumns = columns;
        mTabStop = new boolean[mColumns];
        mTermOut = termOut;
        reset();
    }

    public void updateSize(int columns, int rows) {
        if (mRows == rows && mColumns == columns) {
            return;
        }
        if (columns <= 0) {
            throw new IllegalArgumentException("rows:" + columns);
        }

        if (rows <= 0) {
            throw new IllegalArgumentException("rows:" + rows);
        }

        String transcriptText = mScreen.getTranscriptText();

        //mScreen.resize(columns, rows, mForeColor, mBackColor);
	mScreen.resize(columns,rows,0);

        if (mRows != rows) {
            mRows = rows;
            mTopMargin = 0;
            mBottomMargin = mRows;
        }
        if (mColumns != columns) {
            int oldColumns = mColumns;
            mColumns = columns;
            boolean[] oldTabStop = mTabStop;
            mTabStop = new boolean[mColumns];
            int toTransfer = Math.min(oldColumns, columns);
            System.arraycopy(oldTabStop, 0, mTabStop, 0, toTransfer);
            while (mCursorCol >= columns) {
                mCursorCol -= columns;
                mCursorRow = Math.min(mBottomMargin-1, mCursorRow + 1);
            }
        }
        mCursorRow = 0;
        mCursorCol = 0;
        mAboutToAutoWrap = false;

        int end = transcriptText.length()-1;
        while ((end >= 0) && transcriptText.charAt(end) == '\n') {
            end--;
        }
        for(int i = 0; i <= end; i++) {
            byte c = (byte) transcriptText.charAt(i);
            if (c == '\n') {
                setCursorCol(0);
                doLinefeed();
            } else {
                emit(c);
            }
        }
    }

    public final int getCursorRow() {
        return mCursorRow;
    }
    public final int getCursorCol() {
        return mCursorCol;
    }

    public final boolean getKeypadApplicationMode() {
        return mbKeypadApplicationMode;
    }

    private void setDefaultTabStops() {
        for (int i = 0; i < mColumns; i++) {
            mTabStop[i] = (i & 7) == 0 && i != 0;
        }
    }
    public void append(byte[] buffer, int base, int length) {
        for (int i = 0; i < length; i++) {
            byte b = buffer[base + i];
            try {
                /*if (TermDebug.LOG_CHARACTERS_FLAG) {
                    char printableB = (char) b;
                    if (b < 32 || b > 126) {
                        printableB = ' ';
                    }
                    //Log.w(TAG, "'" + Character.toString(printableB) + "' (" + Integer.toString(b) + ")");
                }*/
                process(b);
                mProcessedCharCount++;
            } catch (Exception e) {
                Log.e(TAG, "Exception while processing character " + Integer.toString(mProcessedCharCount) + " code " + Integer.toString(b), e);
            }
        }
    }

    private void process(byte b) {
        switch (b) {
        case 0: // NUL
            // Do nothing
            break;

        case 7: // BEL
            // Do nothing
            break;

        case 8: // BS
            setCursorCol(Math.max(0, mCursorCol - 1));
            break;

        case 9: // HT
            // Move to next tab stop, but not past edge of screen
            setCursorCol(nextTabStop(mCursorCol));
            break;

        case 13:
            setCursorCol(0);
            break;

        case 10: // CR
        case 11: // VT
        case 12: // LF
            doLinefeed();
            break;

        case 14: // SO:
            setAltCharSet(true);
            break;

        case 15: // SI:
            setAltCharSet(false);
            break;


        case 24: // CAN
        case 26: // SUB
            if (mEscapeState != ESC_NONE) {
                mEscapeState = ESC_NONE;
                emit((byte) 127);
            }
            break;

        case 27: // ESC
            // Always starts an escape sequence
            startEscapeSequence(ESC);
            break;

        case (byte) 0x9b: // CSI
            startEscapeSequence(ESC_LEFT_SQUARE_BRACKET);
            break;

        default:
            mContinueSequence = false;
            switch (mEscapeState) {
            case ESC_NONE:
                if (b >= 32) {
                    emit(b);
                }
                break;

            case ESC:
                doEsc(b);
                break;

            case ESC_POUND:
                doEscPound(b);
                break;

            case ESC_SELECT_LEFT_PAREN:
                doEscSelectLeftParen(b);
                break;

            case ESC_SELECT_RIGHT_PAREN:
                doEscSelectRightParen(b);
                break;

            case ESC_LEFT_SQUARE_BRACKET:
                doEscLeftSquareBracket(b);
                break;

            case ESC_LEFT_SQUARE_BRACKET_QUESTION_MARK:
                doEscLSBQuest(b);
                break;

            default:
                unknownSequence(b);
                break;
            }
            if (!mContinueSequence) {
                mEscapeState = ESC_NONE;
            }
            break;
        }
    }

    private void setAltCharSet(boolean alternateCharSet) {
        mAlternateCharSet = alternateCharSet;
    }

    private int nextTabStop(int cursorCol) {
        for (int i = cursorCol; i < mColumns; i++) {
            if (mTabStop[i]) {
                return i;
            }
        }
        return mColumns - 1;
    }

    private void doEscLSBQuest(byte b) {
        int mask = getDecFlagsMask(getArg0(0));
        switch (b) {
        case 'h': // Esc [ ? Pn h - DECSET
            mDecFlags |= mask;
            break;

        case 'l': // Esc [ ? Pn l - DECRST
            mDecFlags &= ~mask;
            break;

        case 'r': // Esc [ ? Pn r - restore
            mDecFlags = (mDecFlags & ~mask) | (mSavedDecFlags & mask);
            break;

        case 's': // Esc [ ? Pn s - save
            mSavedDecFlags = (mSavedDecFlags & ~mask) | (mDecFlags & mask);
            break;

        default:
            parseArg(b);
            break;
        }

        // 132 column mode
        if ((mask & K_132_COLUMN_MODE_MASK) != 0) {
            // We don't actually set 132 cols, but we do want the
            // side effect of clearing the screen and homing the cursor.
            blockClear(0, 0, mColumns, mRows);
            setCursorRowCol(0, 0);
        }

        // origin mode
        if ((mask & K_ORIGIN_MODE_MASK) != 0) {
            // Home the cursor.
            setCursorPosition(0, 0);
        }
    }

    private int getDecFlagsMask(int argument) {
        if (argument >= 1 && argument <= 9) {
            return (1 << argument);
        }

        return 0;
    }

    private void startEscapeSequence(int escapeState) {
        mEscapeState = escapeState;
        mArgIndex = 0;
        for (int j = 0; j < MAX_ESCAPE_PARAMETERS; j++) {
            mArgs[j] = -1;
        }
    }

    private void doLinefeed() {
        int newCursorRow = mCursorRow + 1;
        if (newCursorRow >= mBottomMargin) {
            scroll();
            newCursorRow = mBottomMargin - 1;
        }
        setCursorRow(newCursorRow);
    }

    private void continueSequence() {
        mContinueSequence = true;
    }

    private void continueSequence(int state) {
        mEscapeState = state;
        mContinueSequence = true;
    }

    private void doEscSelectLeftParen(byte b) {
        doSelectCharSet(true, b);
    }

    private void doEscSelectRightParen(byte b) {
        doSelectCharSet(false, b);
    }

    private void doSelectCharSet(boolean isG0CharSet, byte b) {
        switch (b) {
        case 'A': // United Kingdom character set
            break;
        case 'B': // ASCII set
            break;
        case '0': // Special Graphics
            break;
        case '1': // Alternate character set
            break;
        case '2':
            break;
        default:
            unknownSequence(b);
        }
    }

    private void doEscPound(byte b) {
        switch (b) {
        case '8': // Esc # 8 - DECALN alignment test
            mScreen.blockSet(0, 0, mColumns, mRows, 69,0);// , getForeColor(), getBackColor());
            break;

        default:
            unknownSequence(b);
            break;
        }
    }

    private void doEsc(byte b) {
        switch (b) {
        case '#':
            continueSequence(ESC_POUND);
            break;

        case '(':
            continueSequence(ESC_SELECT_LEFT_PAREN);
            break;

        case ')':
            continueSequence(ESC_SELECT_RIGHT_PAREN);
            break;

        case '7': // DECSC save cursor
            mSavedCursorRow = mCursorRow;
            mSavedCursorCol = mCursorCol;
            break;

        case '8': // DECRC restore cursor
            setCursorRowCol(mSavedCursorRow, mSavedCursorCol);
            break;

        case 'D': // INDEX
            doLinefeed();
            break;

        case 'E': // NEL
            setCursorCol(0);
            doLinefeed();
            break;

        case 'F': // Cursor to lower-left corner of screen
            setCursorRowCol(0, mBottomMargin - 1);
            break;

        case 'H': // Tab set
            mTabStop[mCursorCol] = true;
            break;

        case 'M': // Reverse index
            if (mCursorRow <= mTopMargin) {
                mScreen.blockCopy(0, mTopMargin, mColumns, mBottomMargin
                        - (mTopMargin + 1), 0, mTopMargin + 1);
                blockClear(0, mTopMargin, mColumns);
            } else {
                mCursorRow--;
            }

            break;

        case 'N': // SS2
            unimplementedSequence(b);
            break;

        case '0': // SS3
            unimplementedSequence(b);
            break;

        case 'P': // Device control string
            unimplementedSequence(b);
            break;

        case 'Z': // return terminal ID
            sendDeviceAttributes();
            break;

        case '[':
            continueSequence(ESC_LEFT_SQUARE_BRACKET);
            break;

        case '=': // DECKPAM
            mbKeypadApplicationMode = true;
            break;

        case '>' : // DECKPNM
            mbKeypadApplicationMode = false;
            break;

        default:
            unknownSequence(b);
            break;
        }
    }

    private void doEscLeftSquareBracket(byte b) {
        switch (b) {
        case '@': // ESC [ Pn @ - ICH Insert Characters
        {
            int charsAfterCursor = mColumns - mCursorCol;
            int charsToInsert = Math.min(getArg0(1), charsAfterCursor);
            int charsToMove = charsAfterCursor - charsToInsert;
            mScreen.blockCopy(mCursorCol, mCursorRow, charsToMove, 1,
                    mCursorCol + charsToInsert, mCursorRow);
            blockClear(mCursorCol, mCursorRow, charsToInsert);
        }
            break;

        case 'A': // ESC [ Pn A - Cursor Up
            setCursorRow(Math.max(mTopMargin, mCursorRow - getArg0(1)));
            break;

        case 'B': // ESC [ Pn B - Cursor Down
            setCursorRow(Math.min(mBottomMargin - 1, mCursorRow + getArg0(1)));
            break;

        case 'C': // ESC [ Pn C - Cursor Right
            setCursorCol(Math.min(mColumns - 1, mCursorCol + getArg0(1)));
            break;

        case 'D': // ESC [ Pn D - Cursor Left
            setCursorCol(Math.max(0, mCursorCol - getArg0(1)));
            break;

        case 'G': // ESC [ Pn G - Cursor Horizontal Absolute
            setCursorCol(Math.min(Math.max(1, getArg0(1)), mColumns) - 1);
            break;

        case 'H': // ESC [ Pn ; H - Cursor Position
            setHorizontalVerticalPosition();
            break;

        case 'J': // ESC [ Pn J - Erase in Display
            switch (getArg0(0)) {
            case 0: // Clear below
                blockClear(mCursorCol, mCursorRow, mColumns - mCursorCol);
                blockClear(0, mCursorRow + 1, mColumns,
                        mBottomMargin - (mCursorRow + 1));
                break;

            case 1: // Erase from the start of the screen to the cursor.
                blockClear(0, mTopMargin, mColumns, mCursorRow - mTopMargin);
                blockClear(0, mCursorRow, mCursorCol + 1);
                break;

            case 2: // Clear all
                blockClear(0, mTopMargin, mColumns, mBottomMargin - mTopMargin);
                break;

            default:
                unknownSequence(b);
                break;
            }
            break;

        case 'K': // ESC [ Pn K - Erase in Line
            switch (getArg0(0)) {
            case 0: // Clear to right
                blockClear(mCursorCol, mCursorRow, mColumns - mCursorCol);
                break;

            case 1: // Erase start of line to cursor (including cursor)
                blockClear(0, mCursorRow, mCursorCol + 1);
                break;

            case 2: // Clear whole line
                blockClear(0, mCursorRow, mColumns);
                break;

            default:
                unknownSequence(b);
                break;
            }
            break;

        case 'L': // Insert Lines
        {
            int linesAfterCursor = mBottomMargin - mCursorRow;
            int linesToInsert = Math.min(getArg0(1), linesAfterCursor);
            int linesToMove = linesAfterCursor - linesToInsert;
            mScreen.blockCopy(0, mCursorRow, mColumns, linesToMove, 0,
                    mCursorRow + linesToInsert);
            blockClear(0, mCursorRow, mColumns, linesToInsert);
        }
            break;

        case 'M': // Delete Lines
        {
            int linesAfterCursor = mBottomMargin - mCursorRow;
            int linesToDelete = Math.min(getArg0(1), linesAfterCursor);
            int linesToMove = linesAfterCursor - linesToDelete;
            mScreen.blockCopy(0, mCursorRow + linesToDelete, mColumns,
                    linesToMove, 0, mCursorRow);
            blockClear(0, mCursorRow + linesToMove, mColumns, linesToDelete);
        }
            break;

        case 'P': // Delete Characters
        {
            int charsAfterCursor = mColumns - mCursorCol;
            int charsToDelete = Math.min(getArg0(1), charsAfterCursor);
            int charsToMove = charsAfterCursor - charsToDelete;
            mScreen.blockCopy(mCursorCol + charsToDelete, mCursorRow,
                    charsToMove, 1, mCursorCol, mCursorRow);
            blockClear(mCursorCol + charsToMove, mCursorRow, charsToDelete);
        }
            break;

        case 'T': // Mouse tracking
            unimplementedSequence(b);
            break;

        case '?': // Esc [ ? -- start of a private mode set
            continueSequence(ESC_LEFT_SQUARE_BRACKET_QUESTION_MARK);
            break;

        case 'c': // Send device attributes
            sendDeviceAttributes();
            break;

        case 'd': // ESC [ Pn d - Vert Position Absolute
            setCursorRow(Math.min(Math.max(1, getArg0(1)), mRows) - 1);
            break;

        case 'f': // Horizontal and Vertical Position
            setHorizontalVerticalPosition();
            break;

        case 'g': // Clear tab stop
            switch (getArg0(0)) {
            case 0:
                mTabStop[mCursorCol] = false;
                break;

            case 3:
                for (int i = 0; i < mColumns; i++) {
                    mTabStop[i] = false;
                }
                break;

            default:
                // Specified to have no effect.
                break;
            }
            break;

        case 'h': // Set Mode
            doSetMode(true);
            break;

        case 'l': // Reset Mode
            doSetMode(false);
            break;

        case 'm': // Esc [ Pn m - character attributes.
            selectGraphicRendition();
            break;

        case 'r': // Esc [ Pn ; Pn r - set top and bottom margins
        {

            int top = Math.max(0, Math.min(getArg0(1) - 1, mRows - 2));
            int bottom = Math.max(top + 2, Math.min(getArg1(mRows), mRows));
            mTopMargin = top;
            mBottomMargin = bottom;

            setCursorRowCol(mTopMargin, 0);
        }
            break;

        default:
            parseArg(b);
            break;
        }
    }

    private void selectGraphicRendition() {
        for (int i = 0; i <= mArgIndex; i++) {
            int code = mArgs[i];
            if ( code < 0) {
                if (mArgIndex > 0) {
                    continue;
                } else {
                    code = 0;
                }
            }


            if (code == 0) { // reset
                mInverseColors = false;
                mForeColor = 7;
                mBackColor = 0;
            } else if (code == 1) { // bold
                mForeColor |= 0x8;
            } else if (code == 4) { // underscore
                mBackColor |= 0x8;
            } else if (code == 7) { // inverse
                mInverseColors = true;
            } else if (code == 22) { // Normal color or intensity, neither bright, bold nor faint
                mForeColor &= 0x7;
            } else if (code == 24) { // underline: none
                mBackColor &= 0x7;
            } else if (code == 27) { // image: positive
                mInverseColors = false;
            } else if (code >= 30 && code <= 37) { // foreground color
                mForeColor = (mForeColor & 0x8) | (code - 30);
            } else if (code == 39) { // set default text color
                mForeColor = 7;
                mBackColor = mBackColor & 0x7;
            } else if (code >= 40 && code <= 47) { // background color
                mBackColor = (mBackColor & 0x8) | (code - 40);
            } else if (code == 49) { // set default background color
                mBackColor = mBackColor & 0x8; // color 0, but preserve underscore.
            } else {
                //if (TermDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
                 //   Log.w(TermDebug.LOG_TAG, String.format("SGR unknown code %d", code));
                //}
            }
        }
    }

    private void blockClear(int sx, int sy, int w) {
        blockClear(sx, sy, w, 1);
    }

    private void blockClear(int sx, int sy, int w, int h) {
        mScreen.blockSet(sx, sy, w, h, 32,0);//, getForeColor(), getBackColor());
    }

    private int getForeColor() {
        return mInverseColors ?
                ((mBackColor & 0x7) | (mForeColor & 0x8)) : mForeColor;
    }

    private int getBackColor() {
        return mInverseColors ?
                ((mForeColor & 0x7) | (mBackColor & 0x8)) : mBackColor;
    }

    private void doSetMode(boolean newValue) {
        int modeBit = getArg0(0);
        switch (modeBit) {
        case 4:
            mInsertMode = newValue;
            break;

        case 20:
            mAutomaticNewlineMode = newValue;
            break;

        default:
            unknownParameter(modeBit);
            break;
        }
    }

    private void setHorizontalVerticalPosition() {

        setCursorPosition(getArg1(1) - 1, getArg0(1) - 1);
    }

    private void setCursorPosition(int x, int y) {
        int effectiveTopMargin = 0;
        int effectiveBottomMargin = mRows;
        if ((mDecFlags & K_ORIGIN_MODE_MASK) != 0) {
            effectiveTopMargin = mTopMargin;
            effectiveBottomMargin = mBottomMargin;
        }
        int newRow =
                Math.max(effectiveTopMargin, Math.min(effectiveTopMargin + y,
                        effectiveBottomMargin - 1));
        int newCol = Math.max(0, Math.min(x, mColumns - 1));
        setCursorRowCol(newRow, newCol);
    }

    private void sendDeviceAttributes() {
        byte[] attributes =
                {
                /* VT100 */
                 (byte) 27, (byte) '[', (byte) '?', (byte) '1',
                 (byte) ';', (byte) '2', (byte) 'c'

                /* VT220
                (byte) 27, (byte) '[', (byte) '?', (byte) '6',
                (byte) '0',  (byte) ';',
                (byte) '1',  (byte) ';',
                (byte) '2',  (byte) ';',
                (byte) '6',  (byte) ';',
                (byte) '8',  (byte) ';',
                (byte) '9',  (byte) ';',
                (byte) '1',  (byte) '5', (byte) ';',
                (byte) 'c'
                */
                };

        write(attributes);
    }

    /**
     * Send data to the shell process
     * @param data
     */
    private void write(byte[] data) {
        try {
            mTermOut.write(data);
            mTermOut.flush();
        } catch (IOException e) {
            // Ignore exception
            // We don't really care if the receiver isn't listening.
            // We just make a best effort to answer the query.
        }
    }

    private void scroll() {
        //System.out.println("Scroll(): mTopMargin " + mTopMargin + " mBottomMargin " + mBottomMargin);
        mScrollCounter ++;
        mScreen.scroll(mTopMargin, mBottomMargin,0);// getForeColor(), getBackColor());
    }

    private void parseArg(byte b) {
        if (b >= '0' && b <= '9') {
            if (mArgIndex < mArgs.length) {
                int oldValue = mArgs[mArgIndex];
                int thisDigit = b - '0';
                int value;
                if (oldValue >= 0) {
                    value = oldValue * 10 + thisDigit;
                } else {
                    value = thisDigit;
                }
                mArgs[mArgIndex] = value;
            }
            continueSequence();
        } else if (b == ';') {
            if (mArgIndex < mArgs.length) {
                mArgIndex++;
            }
            continueSequence();
        } else {
            unknownSequence(b);
        }
    }

    private int getArg0(int defaultValue) {
        return getArg(0, defaultValue);
    }

    private int getArg1(int defaultValue) {
        return getArg(1, defaultValue);
    }

    private int getArg(int index, int defaultValue) {
        int result = mArgs[index];
        if (result < 0) {
            result = defaultValue;
        }
        return result;
    }

    private void unimplementedSequence(byte b) {
//        if (TermDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
 //           logError("unimplemented", b);
  //      }
        finishSequence();
    }

    private void unknownSequence(byte b) {
   //     if (TermDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
    //        logError("unknown", b);
     //   }
        finishSequence();
    }

    private void unknownParameter(int parameter) {
      /*  if (TermDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
            StringBuilder buf = new StringBuilder();
            buf.append("Unknown parameter");
            buf.append(parameter);
            logError(buf.toString());
        }
	*/
    }

    private void logError(String errorType, byte b) {
      /*  if (TermDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
            StringBuilder buf = new StringBuilder();
            buf.append(errorType);
            buf.append(" sequence ");
            buf.append(" EscapeState: ");
            buf.append(mEscapeState);
            buf.append(" char: '");
            buf.append((char) b);
            buf.append("' (");
            buf.append(b);
            buf.append(")");
            boolean firstArg = true;
            for (int i = 0; i <= mArgIndex; i++) {
                int value = mArgs[i];
                if (value >= 0) {
                    if (firstArg) {
                        firstArg = false;
                        buf.append("args = ");
                    }
                    buf.append(String.format("%d; ", value));
                }
            }
            logError(buf.toString());
        }
	*/
    }

    private void logError(String error) {
        //if (TermDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
//            Log.e(TermDebug.LOG_TAG, error);
 //       }
        finishSequence();
    }

    private void finishSequence() {
        mEscapeState = ESC_NONE;
    }

    private boolean autoWrapEnabled() {
        return (mDecFlags & K_WRAPAROUND_MODE_MASK) != 0;
    }

    private void emit(byte b) {
        boolean autoWrap = autoWrapEnabled();

        if (autoWrap) {
            if (mCursorCol == mColumns - 1 && mAboutToAutoWrap) {
                mScreen.setLineWrap(mCursorRow);
                mCursorCol = 0;
                if (mCursorRow + 1 < mBottomMargin) {
                    mCursorRow++;
                } else {
                    scroll();
                }
            }
        }

        if (mInsertMode) { // Move character to right one space
            int destCol = mCursorCol + 1;
            if (destCol < mColumns) {
                mScreen.blockCopy(mCursorCol, mCursorRow, mColumns - destCol,
                        1, destCol, mCursorRow);
            }
        }

        mScreen.set(mCursorCol, mCursorRow, b, 0);// getForeColor(), getBackColor());

        if (autoWrap) {
            mAboutToAutoWrap = (mCursorCol == mColumns - 1);
        }

        mCursorCol = Math.min(mCursorCol + 1, mColumns - 1);
    }

    private void setCursorRow(int row) {
        mCursorRow = row;
        mAboutToAutoWrap = false;
    }

    private void setCursorCol(int col) {
        mCursorCol = col;
        mAboutToAutoWrap = false;
    }

    private void setCursorRowCol(int row, int col) {
        mCursorRow = Math.min(row, mRows-1);
        mCursorCol = Math.min(col, mColumns-1);
        mAboutToAutoWrap = false;
    }

    public int getScrollCounter() {
        return mScrollCounter;
    }

    public void clearScrollCounter() {
        mScrollCounter = 0;
    }

    public void reset() {
        mCursorRow = 0;
        mCursorCol = 0;
        mArgIndex = 0;
        mContinueSequence = false;
        mEscapeState = ESC_NONE;
        mSavedCursorRow = 0;
        mSavedCursorCol = 0;
        mDecFlags = 0;
        mSavedDecFlags = 0;
        mInsertMode = false;
        mAutomaticNewlineMode = false;
        mTopMargin = 0;
        mBottomMargin = mRows;
        mAboutToAutoWrap = false;
        mForeColor = 7;
        mBackColor = 0;
        mInverseColors = false;
        mbKeypadApplicationMode = false;
        mAlternateCharSet = false;
        setDefaultTabStops();
        blockClear(0, 0, mColumns, mRows);
    }

    public String getSelectedText(int x1, int y1, int x2, int y2) {
        return mScreen.getSelectedText(x1, y1, x2, y2);
    }
}
